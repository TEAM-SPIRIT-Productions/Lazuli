{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lazuli Stats courtesy of PePy Lazuli is a pip-compatible, Python-based package for interacting with AzureMSv316 -based databases. Lazuli is inspired by and based on the SwordieDB project. Lazuli allows access to character and inventory attributes in AzureMSv316 -based databases. Current Status: Now Available on PyPi (See changelog ) Quick Start Installation via PyPi/Pip: 1. Run pip install lazuli inside of your venv (or global, if desired) - see wiki for how to generate venv 2. Import the module in your project - from lazuli.database import Lazuli 3. Create an Azure database object using the Lazuli class constructor - azure = Lazuli() - See the Wiki for full examples - See the API Docs for more in-depth technical documentation 4. Query - E.g. number_of_players_online = azure.get_online_count() gives number (int) of accounts currently connected to the server Documentation: Kindly refer to the Project Wiki for detailed documentation. The Discussions Page is currently open for any questions! Please report any issues !","title":"Home"},{"location":"#lazuli","text":"Stats courtesy of PePy Lazuli is a pip-compatible, Python-based package for interacting with AzureMSv316 -based databases. Lazuli is inspired by and based on the SwordieDB project. Lazuli allows access to character and inventory attributes in AzureMSv316 -based databases.","title":"Lazuli"},{"location":"#current-status-now-available-on-pypi-see-changelog","text":"","title":"Current Status: Now Available on PyPi (See changelog)"},{"location":"#quick-start","text":"Installation via PyPi/Pip: 1. Run pip install lazuli inside of your venv (or global, if desired) - see wiki for how to generate venv 2. Import the module in your project - from lazuli.database import Lazuli 3. Create an Azure database object using the Lazuli class constructor - azure = Lazuli() - See the Wiki for full examples - See the API Docs for more in-depth technical documentation 4. Query - E.g. number_of_players_online = azure.get_online_count() gives number (int) of accounts currently connected to the server","title":"Quick Start"},{"location":"#documentation","text":"Kindly refer to the Project Wiki for detailed documentation. The Discussions Page is currently open for any questions! Please report any issues !","title":"Documentation:"},{"location":"CHANGELOG/","text":"CHANGELOG: v0.0.6 Migrate all static functions to utility module (breaking API change!) Migrate name extraction (from list of player data) to utility module Add ranking methods to Lazuli class Add get_db_all_hits utility function, for getting all DB matches Add get_db_all_hits`` wrapper function in database.Lazuli` Made Lazuli::get_online_list use Lazuli::get_db_all_hits v0.0.5 Minor fix: type error for account instantiation Generate API Docs Feature: Fetch usernames of all players online v0.0.4 Open up Discussions page Add docstrings v0.0.3 Add inventory model v0.0.2 Add character model Add account model v0.0.1 Initialise project Add database model (with placeholder for Account and Character objects)","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG:"},{"location":"CHANGELOG/#v006","text":"Migrate all static functions to utility module (breaking API change!) Migrate name extraction (from list of player data) to utility module Add ranking methods to Lazuli class Add get_db_all_hits utility function, for getting all DB matches Add get_db_all_hits`` wrapper function in database.Lazuli` Made Lazuli::get_online_list use Lazuli::get_db_all_hits","title":"v0.0.6"},{"location":"CHANGELOG/#v005","text":"Minor fix: type error for account instantiation Generate API Docs Feature: Fetch usernames of all players online","title":"v0.0.5"},{"location":"CHANGELOG/#v004","text":"Open up Discussions page Add docstrings","title":"v0.0.4"},{"location":"CHANGELOG/#v003","text":"Add inventory model","title":"v0.0.3"},{"location":"CHANGELOG/#v002","text":"Add character model Add account model","title":"v0.0.2"},{"location":"CHANGELOG/#v001","text":"Initialise project Add database model (with placeholder for Account and Character objects)","title":"v0.0.1"},{"location":"reference/lazuli/","text":"Module lazuli This is the init file for the package - Compiled by KOOKIIE Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module provides a dictionary mapping all Job IDs to their respective Job names. All efforts have been made to trace Job IDs in both GMS and KMS accurately. Notable ommissions (Plase contribute if you have their Job IDs): - SAO Classes: Kirito, Asuna, Leafa - Sengoku Class (Special): Ayame - Explorer Class (Special): Zen View Source \"\"\"This is the init file for the package - Compiled by KOOKIIE Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module provides a dictionary mapping all Job IDs to their respective Job names. All efforts have been made to trace Job IDs in both GMS and KMS accurately. Notable ommissions (Plase contribute if you have their Job IDs): - SAO Classes: Kirito, Asuna, Leafa - Sengoku Class (Special): Ayame - Explorer Class (Special): Zen \"\"\" JOBS = { # Explorer Classes ( Aventurer in MSEA ) '0' : 'Beginner' , # Explorer Warrior '100' : 'Warrior' , # Explorer Warrior 1 ( Common ) '110' : 'Fighter' , '111' : 'Crusader' , '112' : 'Hero' , '120' : 'Page' , '121' : 'White Knight' , '122' : 'Paladin' , '130' : 'Spearman' , '131' : 'Dragon Knight' , '132' : 'Dark Knight' , # Explorer Mage '200' : 'Magician' , # Explorer Mage 1 ( Common ) '210' : 'Fire Poison Wizard' , '211' : 'Fire Poison Mage' , '212' : 'Fire Poison Archmage' , '220' : 'Ice Lightning Wizard' , '221' : 'Ice Lightning Mage' , '222' : 'Ice Lightning Archmage' , '230' : 'Cleric' , '231' : 'Priest' , '232' : 'Bishop' , # Explorer Bowmen '300' : 'Archer' , # Explorer Bowman 1 ( Common ) '310' : 'Hunter' , '311' : 'Ranger' , '312' : 'Bowmaster' , '320' : 'Cross Bowman' , '321' : 'Sniper' , '322' : 'Marksman' , # Special Explorer : Pathfinder '301' : 'Pathfinder' , # PF 1 - Not sure why they broke their own conventions '330' : 'Pathfinder' , # PF 2 '331' : 'Pathfinder' , # PF 3 '332' : 'Pathfinder' , # PF 4 # Explorer Thieves '400' : 'Rogue' , # Explorer Thieves 1 ( Common ) '410' : 'Assassin' , '411' : 'Hermit' , '412' : 'Night Lord' , '420' : 'Bandit' , '421' : 'Chief Bandit' , '422' : 'Shadower' , # Special Explorer : Dual Blades '430' : 'Blade Recruit' , '431' : 'Blade Acolyte' , '432' : 'Blade Specialist' , '433' : 'Blade Lord' , '434' : 'Blade Master' , # Explorer Pirates '500' : 'Pirate' , # Explorer Pirates 1 ( Common ) '510' : 'Brawler' , '511' : 'Marauder' , '512' : 'Buccaneer' , # ( aka Viper in MSEA / KMS ) '520' : 'Gunslinger' , '521' : 'Outlaw' , '522' : 'Corsair' , # Special Explorer : Canonneer '501' : 'Cannon Shooter' , '530' : 'Cannoneer' , '531' : 'Cannon Trooper' , '532' : 'Cannon Master' , # Special Explorer : Jett '508' : 'Jett' , # Jett 1 - Not sure why they broke their own conventions '570' : 'Jett' , # Jett 2 '571' : 'Jett' , # Jett 3 '572' : 'Jett' , # Jett 4 # KoC Classes '1000' : 'Noblesse' , # KoC Beginner # Soul Master in MSEA / KMS '1100' : 'Dawn Warrior' , # DW 1 '1110' : 'Dawn Warrior' , # DW 2 '1111' : 'Dawn Warrior' , # DW 3 '1112' : 'Dawn Warrior' , # DW 4 # Flame Wizard in MSEA / KMS '1200' : 'Blaze Wizard' , # BW 1 '1210' : 'Blaze Wizard' , # BW 2 '1211' : 'Blaze Wizard' , # BW 3 '1212' : 'Blaze Wizard' , # BW 4 # Wind Breaker in MSEA / KMS '1300' : 'Wind Archer' , # WA 1 '1310' : 'Wind Archer' , # WA 2 '1311' : 'Wind Archer' , # WA 3 '1312' : 'Wind Archer' , # WA 4 '1400' : 'Night Walker' , # NW 1 '1410' : 'Night Walker' , # NW 2 '1411' : 'Night Walker' , # NW 3 '1412' : 'Night Walker' , # NW 4 # Striker in MSEA / KMS '1500' : 'Thunder Breaker' , # TB 1 '1510' : 'Thunder Breaker' , # TB 2 '1511' : 'Thunder Breaker' , # TB 3 '1512' : 'Thunder Breaker' , # TB 4 # Heroes of Maple / Legends Classes # The 6 Hero classes ( M , A , P , L , E , S ) have 200 X beginner job IDs '2000' : 'Aran' , # Aran Beginner ( aka Legend ) '2100' : 'Aran' , # Aran 1 '2110' : 'Aran' , # Aran 2 '2111' : 'Aran' , # Aran 3 '2112' : 'Aran' , # Aran 4 '2001' : 'Evan' , # Evan Beginner '2200' : 'Evan' , # Evan 1 '2210' : 'Evan' , # Evan 2 '2211' : 'Evan' , # Evan 3 '2212' : 'Evan' , # Evan 4 '2213' : 'Evan' , # Evan 5 '2214' : 'Evan' , # Evan 6 '2215' : 'Evan' , # Evan 7 '2216' : 'Evan' , # Evan 8 '2217' : 'Evan' , # Evan 9 '2218' : 'Evan' , # Evan 10 '2002' : 'Mercedes' , # Mercedes Beginner '2300' : 'Mercedes' , # Mercedes 1 '2310' : 'Mercedes' , # Mercedes 2 '2311' : 'Mercedes' , # Mercedes 3 '2312' : 'Mercedes' , # Mercedes 4 '2003' : 'Phantom' , # Phantom Beginner '2400' : 'Phantom' , # Phantom 1 '2410' : 'Phantom' , # Phantom 2 '2411' : 'Phantom' , # Phantom 3 '2412' : 'Phantom' , # Phantom 4 # Eunwol in MSEA / KMS '2005' : 'Shade' , # Shade Beginner '2500' : 'Shade' , # Shade 1 '2510' : 'Shade' , # Shade 2 '2511' : 'Shade' , # Shade 3 '2512' : 'Shade' , # Shade 4 '2004' : 'Luminous' , # Luminous Beginner '2700' : 'Luminous' , # Luminous 1 '2710' : 'Luminous' , # Luminous 2 '2711' : 'Luminous' , # Luminous 3 '2712' : 'Luminous' , # Luminous 4 # Resistance Classes '3000' : 'Citizen' , # Non - Demon / Xenon Resistance # Resistance classes have 300 X beginner job IDs '3001' : 'Demon' , # Demon classes Beginner ( Demons have their own beginner classes ) '3100' : 'Demon Slayer' , # DS 1 '3110' : 'Demon Slayer' , # DS 2 '3111' : 'Demon Slayer' , # DS 3 '3112' : 'Demon Slayer' , # DS 4 '3101' : 'Demon Avenger' , # DA 1 '3120' : 'Demon Avenger' , # DA 2 '3121' : 'Demon Avenger' , # DA 3 '3122' : 'Demon Avenger' , # DA 4 '3200' : 'Battle Mage' , # BaM 1 '3210' : 'Battle Mage' , # BaM 2 '3211' : 'Battle Mage' , # BaM 3 '3212' : 'Battle Mage' , # BaM 4 '3300' : 'Wild Hunter' , # WH 1 '3310' : 'Wild Hunter' , # WH 2 '3311' : 'Wild Hunter' , # WH 3 '3312' : 'Wild Hunter' , # WH 4 '3500' : 'Mechanic' , # Mech 1 '3510' : 'Mechanic' , # Mech 2 '3511' : 'Mechanic' , # Mech 3 '3512' : 'Mechanic' , # Mech 4 '3002' : 'Xenon' , # Xenon Beginner ( Xenons have their own beginner class ) '3600' : 'Xenon' , # Xenon 1 '3610' : 'Xenon' , # Xenon 2 '3611' : 'Xenon' , # Xenon 3 '3612' : 'Xenon' , # Xenon 4 '3700' : 'Blaster' , # Blaster 1 '3710' : 'Blaster' , # Blaster 1 '3711' : 'Blaster' , # Blaster 1 '3712' : 'Blaster' , # Blaster 1 # Sengoku Classes # Sengoku classes have 400 X beginner job IDs '4001' : 'Hayato' , # Hayato Beginner '4100' : 'Hayato' , # Hayato 1 '4110' : 'Hayato' , # Hayato 2 '4111' : 'Hayato' , # Hayato 3 '4112' : 'Hayato' , # Hayato 4 '4002' : 'Kanna' , # Kanna Beginner '4200' : 'Kanna' , # Kanna 1 '4210' : 'Kanna' , # Kanna 2 '4211' : 'Kanna' , # Kanna 3 '4212' : 'Kanna' , # Kanna 4 # Special KoC '5000' : 'Mihile' , # Mihile Beginner ( aka Nameless Warden ) '5100' : 'Mihile' , # Mihile 1 '5110' : 'Mihile' , # Mihile 2 '5111' : 'Mihile' , # Mihile 3 '5112' : 'Mihile' , # Mihile 4 # Nova Classes '6000' : 'Kaiser' , # Kaiser Beginner '6100' : 'Kaiser' , # Kaiser 1 '6110' : 'Kaiser' , # Kaiser 2 '6111' : 'Kaiser' , # Kaiser 3 '6112' : 'Kaiser' , # Kaiser 4 '6001' : 'Angelic Buster' , # AB Beginner '6500' : 'Angelic Buster' , # AB 1 '6510' : 'Angelic Buster' , # AB 2 '6511' : 'Angelic Buster' , # AB 3 '6512' : 'Angelic Buster' , # AB 4 '6002' : 'Cadena' , # Cadena Beginner '6400' : 'Cadena' , # Cadena 1 '6410' : 'Cadena' , # Cadena 2 '6411' : 'Cadena' , # Cadena 3 '6412' : 'Cadena' , # Cadena 4 # Child of God Classes '10000' : 'Zero' , # Zero Beginner '10100' : 'Zero' , # Zero 1 '10110' : 'Zero' , # Zero 2 '10111' : 'Zero' , # Zero 3 '10112' : 'Zero' , # Zero 4 # Child of Furry Classes '11000' : 'Beast Tamer' , # Beast Tamer Beginner '11200' : 'Beast Tamer' , # Beast Tamer 1 '11210' : 'Beast Tamer' , # Beast Tamer 2 '11211' : 'Beast Tamer' , # Beast Tamer 3 '11212' : 'Beast Tamer' , # Beast Tamer 4 # Special : Kinesis '14000' : 'Kinesis' , # Kinesis Beginner '14200' : 'Kinesis' , # Kinesis 1 '14210' : 'Kinesis' , # Kinesis 2 '14211' : 'Kinesis' , # Kinesis 3 '14212' : 'Kinesis' , # Kinesis 4 # Flora Classes '15000' : 'Illium' , # Illium Beginner '15200' : 'Illium' , # Illium 1 '15210' : 'Illium' , # Illium 2 '15211' : 'Illium' , # Illium 3 '15212' : 'Illium' , # Illium 4 '15001' : 'Ark' , # Ark Beginner '15500' : 'Ark' , # Ark 1 '15510' : 'Ark' , # Ark 2 '15511' : 'Ark' , # Ark 3 '15512' : 'Ark' , # Ark 4 '15002' : 'Adele' , # Adele Beginner '15100' : 'Adele' , # Adele 1 '15110' : 'Adele' , # Adele 2 '15112' : 'Adele' , # Adele 3 '15111' : 'Adele' , # Adele 4 # Anima Classes '16000' : 'Hoyoung' , # Hoyoung Beginner '16400' : 'Hoyoung' , # Hoyoung 1 '16410' : 'Hoyoung' , # Hoyoung 2 '16411' : 'Hoyoung' , # Hoyoung 3 '16412' : 'Hoyoung' , # Hoyoung 4 # Special jobs '800' : 'Manager' , '900' : 'GM' , '910' : 'Super GM' , '9000' : 'Additional Skills' , '40000' : 'V-Skills' , # Special : Pink Bean '13000' : 'Pink Bean' , # Pink Bean Beginner '13100' : 'Pink Bean' , # Pink Bean 1 } Sub-modules lazuli.account lazuli.character lazuli.database lazuli.inventory lazuli.utility Variables JOBS","title":"Index"},{"location":"reference/lazuli/#module-lazuli","text":"This is the init file for the package - Compiled by KOOKIIE Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module provides a dictionary mapping all Job IDs to their respective Job names. All efforts have been made to trace Job IDs in both GMS and KMS accurately. Notable ommissions (Plase contribute if you have their Job IDs): - SAO Classes: Kirito, Asuna, Leafa - Sengoku Class (Special): Ayame - Explorer Class (Special): Zen View Source \"\"\"This is the init file for the package - Compiled by KOOKIIE Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module provides a dictionary mapping all Job IDs to their respective Job names. All efforts have been made to trace Job IDs in both GMS and KMS accurately. Notable ommissions (Plase contribute if you have their Job IDs): - SAO Classes: Kirito, Asuna, Leafa - Sengoku Class (Special): Ayame - Explorer Class (Special): Zen \"\"\" JOBS = { # Explorer Classes ( Aventurer in MSEA ) '0' : 'Beginner' , # Explorer Warrior '100' : 'Warrior' , # Explorer Warrior 1 ( Common ) '110' : 'Fighter' , '111' : 'Crusader' , '112' : 'Hero' , '120' : 'Page' , '121' : 'White Knight' , '122' : 'Paladin' , '130' : 'Spearman' , '131' : 'Dragon Knight' , '132' : 'Dark Knight' , # Explorer Mage '200' : 'Magician' , # Explorer Mage 1 ( Common ) '210' : 'Fire Poison Wizard' , '211' : 'Fire Poison Mage' , '212' : 'Fire Poison Archmage' , '220' : 'Ice Lightning Wizard' , '221' : 'Ice Lightning Mage' , '222' : 'Ice Lightning Archmage' , '230' : 'Cleric' , '231' : 'Priest' , '232' : 'Bishop' , # Explorer Bowmen '300' : 'Archer' , # Explorer Bowman 1 ( Common ) '310' : 'Hunter' , '311' : 'Ranger' , '312' : 'Bowmaster' , '320' : 'Cross Bowman' , '321' : 'Sniper' , '322' : 'Marksman' , # Special Explorer : Pathfinder '301' : 'Pathfinder' , # PF 1 - Not sure why they broke their own conventions '330' : 'Pathfinder' , # PF 2 '331' : 'Pathfinder' , # PF 3 '332' : 'Pathfinder' , # PF 4 # Explorer Thieves '400' : 'Rogue' , # Explorer Thieves 1 ( Common ) '410' : 'Assassin' , '411' : 'Hermit' , '412' : 'Night Lord' , '420' : 'Bandit' , '421' : 'Chief Bandit' , '422' : 'Shadower' , # Special Explorer : Dual Blades '430' : 'Blade Recruit' , '431' : 'Blade Acolyte' , '432' : 'Blade Specialist' , '433' : 'Blade Lord' , '434' : 'Blade Master' , # Explorer Pirates '500' : 'Pirate' , # Explorer Pirates 1 ( Common ) '510' : 'Brawler' , '511' : 'Marauder' , '512' : 'Buccaneer' , # ( aka Viper in MSEA / KMS ) '520' : 'Gunslinger' , '521' : 'Outlaw' , '522' : 'Corsair' , # Special Explorer : Canonneer '501' : 'Cannon Shooter' , '530' : 'Cannoneer' , '531' : 'Cannon Trooper' , '532' : 'Cannon Master' , # Special Explorer : Jett '508' : 'Jett' , # Jett 1 - Not sure why they broke their own conventions '570' : 'Jett' , # Jett 2 '571' : 'Jett' , # Jett 3 '572' : 'Jett' , # Jett 4 # KoC Classes '1000' : 'Noblesse' , # KoC Beginner # Soul Master in MSEA / KMS '1100' : 'Dawn Warrior' , # DW 1 '1110' : 'Dawn Warrior' , # DW 2 '1111' : 'Dawn Warrior' , # DW 3 '1112' : 'Dawn Warrior' , # DW 4 # Flame Wizard in MSEA / KMS '1200' : 'Blaze Wizard' , # BW 1 '1210' : 'Blaze Wizard' , # BW 2 '1211' : 'Blaze Wizard' , # BW 3 '1212' : 'Blaze Wizard' , # BW 4 # Wind Breaker in MSEA / KMS '1300' : 'Wind Archer' , # WA 1 '1310' : 'Wind Archer' , # WA 2 '1311' : 'Wind Archer' , # WA 3 '1312' : 'Wind Archer' , # WA 4 '1400' : 'Night Walker' , # NW 1 '1410' : 'Night Walker' , # NW 2 '1411' : 'Night Walker' , # NW 3 '1412' : 'Night Walker' , # NW 4 # Striker in MSEA / KMS '1500' : 'Thunder Breaker' , # TB 1 '1510' : 'Thunder Breaker' , # TB 2 '1511' : 'Thunder Breaker' , # TB 3 '1512' : 'Thunder Breaker' , # TB 4 # Heroes of Maple / Legends Classes # The 6 Hero classes ( M , A , P , L , E , S ) have 200 X beginner job IDs '2000' : 'Aran' , # Aran Beginner ( aka Legend ) '2100' : 'Aran' , # Aran 1 '2110' : 'Aran' , # Aran 2 '2111' : 'Aran' , # Aran 3 '2112' : 'Aran' , # Aran 4 '2001' : 'Evan' , # Evan Beginner '2200' : 'Evan' , # Evan 1 '2210' : 'Evan' , # Evan 2 '2211' : 'Evan' , # Evan 3 '2212' : 'Evan' , # Evan 4 '2213' : 'Evan' , # Evan 5 '2214' : 'Evan' , # Evan 6 '2215' : 'Evan' , # Evan 7 '2216' : 'Evan' , # Evan 8 '2217' : 'Evan' , # Evan 9 '2218' : 'Evan' , # Evan 10 '2002' : 'Mercedes' , # Mercedes Beginner '2300' : 'Mercedes' , # Mercedes 1 '2310' : 'Mercedes' , # Mercedes 2 '2311' : 'Mercedes' , # Mercedes 3 '2312' : 'Mercedes' , # Mercedes 4 '2003' : 'Phantom' , # Phantom Beginner '2400' : 'Phantom' , # Phantom 1 '2410' : 'Phantom' , # Phantom 2 '2411' : 'Phantom' , # Phantom 3 '2412' : 'Phantom' , # Phantom 4 # Eunwol in MSEA / KMS '2005' : 'Shade' , # Shade Beginner '2500' : 'Shade' , # Shade 1 '2510' : 'Shade' , # Shade 2 '2511' : 'Shade' , # Shade 3 '2512' : 'Shade' , # Shade 4 '2004' : 'Luminous' , # Luminous Beginner '2700' : 'Luminous' , # Luminous 1 '2710' : 'Luminous' , # Luminous 2 '2711' : 'Luminous' , # Luminous 3 '2712' : 'Luminous' , # Luminous 4 # Resistance Classes '3000' : 'Citizen' , # Non - Demon / Xenon Resistance # Resistance classes have 300 X beginner job IDs '3001' : 'Demon' , # Demon classes Beginner ( Demons have their own beginner classes ) '3100' : 'Demon Slayer' , # DS 1 '3110' : 'Demon Slayer' , # DS 2 '3111' : 'Demon Slayer' , # DS 3 '3112' : 'Demon Slayer' , # DS 4 '3101' : 'Demon Avenger' , # DA 1 '3120' : 'Demon Avenger' , # DA 2 '3121' : 'Demon Avenger' , # DA 3 '3122' : 'Demon Avenger' , # DA 4 '3200' : 'Battle Mage' , # BaM 1 '3210' : 'Battle Mage' , # BaM 2 '3211' : 'Battle Mage' , # BaM 3 '3212' : 'Battle Mage' , # BaM 4 '3300' : 'Wild Hunter' , # WH 1 '3310' : 'Wild Hunter' , # WH 2 '3311' : 'Wild Hunter' , # WH 3 '3312' : 'Wild Hunter' , # WH 4 '3500' : 'Mechanic' , # Mech 1 '3510' : 'Mechanic' , # Mech 2 '3511' : 'Mechanic' , # Mech 3 '3512' : 'Mechanic' , # Mech 4 '3002' : 'Xenon' , # Xenon Beginner ( Xenons have their own beginner class ) '3600' : 'Xenon' , # Xenon 1 '3610' : 'Xenon' , # Xenon 2 '3611' : 'Xenon' , # Xenon 3 '3612' : 'Xenon' , # Xenon 4 '3700' : 'Blaster' , # Blaster 1 '3710' : 'Blaster' , # Blaster 1 '3711' : 'Blaster' , # Blaster 1 '3712' : 'Blaster' , # Blaster 1 # Sengoku Classes # Sengoku classes have 400 X beginner job IDs '4001' : 'Hayato' , # Hayato Beginner '4100' : 'Hayato' , # Hayato 1 '4110' : 'Hayato' , # Hayato 2 '4111' : 'Hayato' , # Hayato 3 '4112' : 'Hayato' , # Hayato 4 '4002' : 'Kanna' , # Kanna Beginner '4200' : 'Kanna' , # Kanna 1 '4210' : 'Kanna' , # Kanna 2 '4211' : 'Kanna' , # Kanna 3 '4212' : 'Kanna' , # Kanna 4 # Special KoC '5000' : 'Mihile' , # Mihile Beginner ( aka Nameless Warden ) '5100' : 'Mihile' , # Mihile 1 '5110' : 'Mihile' , # Mihile 2 '5111' : 'Mihile' , # Mihile 3 '5112' : 'Mihile' , # Mihile 4 # Nova Classes '6000' : 'Kaiser' , # Kaiser Beginner '6100' : 'Kaiser' , # Kaiser 1 '6110' : 'Kaiser' , # Kaiser 2 '6111' : 'Kaiser' , # Kaiser 3 '6112' : 'Kaiser' , # Kaiser 4 '6001' : 'Angelic Buster' , # AB Beginner '6500' : 'Angelic Buster' , # AB 1 '6510' : 'Angelic Buster' , # AB 2 '6511' : 'Angelic Buster' , # AB 3 '6512' : 'Angelic Buster' , # AB 4 '6002' : 'Cadena' , # Cadena Beginner '6400' : 'Cadena' , # Cadena 1 '6410' : 'Cadena' , # Cadena 2 '6411' : 'Cadena' , # Cadena 3 '6412' : 'Cadena' , # Cadena 4 # Child of God Classes '10000' : 'Zero' , # Zero Beginner '10100' : 'Zero' , # Zero 1 '10110' : 'Zero' , # Zero 2 '10111' : 'Zero' , # Zero 3 '10112' : 'Zero' , # Zero 4 # Child of Furry Classes '11000' : 'Beast Tamer' , # Beast Tamer Beginner '11200' : 'Beast Tamer' , # Beast Tamer 1 '11210' : 'Beast Tamer' , # Beast Tamer 2 '11211' : 'Beast Tamer' , # Beast Tamer 3 '11212' : 'Beast Tamer' , # Beast Tamer 4 # Special : Kinesis '14000' : 'Kinesis' , # Kinesis Beginner '14200' : 'Kinesis' , # Kinesis 1 '14210' : 'Kinesis' , # Kinesis 2 '14211' : 'Kinesis' , # Kinesis 3 '14212' : 'Kinesis' , # Kinesis 4 # Flora Classes '15000' : 'Illium' , # Illium Beginner '15200' : 'Illium' , # Illium 1 '15210' : 'Illium' , # Illium 2 '15211' : 'Illium' , # Illium 3 '15212' : 'Illium' , # Illium 4 '15001' : 'Ark' , # Ark Beginner '15500' : 'Ark' , # Ark 1 '15510' : 'Ark' , # Ark 2 '15511' : 'Ark' , # Ark 3 '15512' : 'Ark' , # Ark 4 '15002' : 'Adele' , # Adele Beginner '15100' : 'Adele' , # Adele 1 '15110' : 'Adele' , # Adele 2 '15112' : 'Adele' , # Adele 3 '15111' : 'Adele' , # Adele 4 # Anima Classes '16000' : 'Hoyoung' , # Hoyoung Beginner '16400' : 'Hoyoung' , # Hoyoung 1 '16410' : 'Hoyoung' , # Hoyoung 2 '16411' : 'Hoyoung' , # Hoyoung 3 '16412' : 'Hoyoung' , # Hoyoung 4 # Special jobs '800' : 'Manager' , '900' : 'GM' , '910' : 'Super GM' , '9000' : 'Additional Skills' , '40000' : 'V-Skills' , # Special : Pink Bean '13000' : 'Pink Bean' , # Pink Bean Beginner '13100' : 'Pink Bean' , # Pink Bean 1 }","title":"Module lazuli"},{"location":"reference/lazuli/#sub-modules","text":"lazuli.account lazuli.character lazuli.database lazuli.inventory lazuli.utility","title":"Sub-modules"},{"location":"reference/lazuli/#variables","text":"JOBS","title":"Variables"},{"location":"reference/lazuli/account/","text":"Module lazuli.account This module holds the Account class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the Account class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql.connector as con class Account : \"\"\"Account object; models AzureMS accounts. Using instance method Lazuli::get_account_by_username(username) or the Lazuli::get_char_by_name(name).account getter will create an Account object instance with attributes identical to the account with username \"username\" (or IGN \"name\" for the latter) in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: account_id: Integer, representing Primary Key for account - Do NOT set manually username: String, representing account username; varchar(64) logged_in: Integer, represents login status of the account; int(1) and not bool for some reason banned: Integer, represents ban status of the account; int(1) and not bool for some reason ban_reason: String, representing account ban reason; text nx: Integer, representing the amount of NX Prepaid the user has maple_points: Integer, representing the amount of Maple Points the user has vp:Integer, representing the amount of Vote Points the user has dp: Integer, representing the amount of Donation Points the user has char_slots: Integer, representing the number of character slots the user has \"\"\" def __init__ ( self , account_info , database_config ): \"\"\"Emulates how account object is handled server-sided Args: account_info: dictionary of user attributes, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _account_info = account_info self . _database_config = database_config self . _account_id = 0 # Primary Key - Do NOT set self . _username = \"\" # varchar(64) self . _logged_in = 0 # int(1) and not bool for some reason self . _banned = 0 # int(1) and not bool for some reason self . _ban_reason = \"\" # text # self._gm = 0 # There are conflicting values in character and accounts - ignored for now self . _nx = 0 self . _maple_points = 0 self . _vp = 0 self . _dp = 0 self . _char_slots = 0 self . init_account_stats () def init_account_stats ( self ): \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account::__init__(account_info, database_config). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance. \"\"\" self . _account_id = self . _account_info [ 'id' ] self . _username = self . _account_info [ 'name' ] self . _logged_in = self . _account_info [ 'loggedin' ] self . _banned = self . _account_info [ 'banned' ] self . _ban_reason = self . _account_info [ 'banreason' ] # self._gm = self._account_info['gm'] # There are conflicting values in character and accounts - ignored for now self . _nx = self . _account_info [ 'nxCash' ] self . _maple_points = self . _account_info [ 'mPoints' ] self . _vp = self . _account_info [ 'vpoints' ] self . _dp = self . _account_info [ 'realcash' ] # Best guess - Might be wrong! self . _char_slots = self . _account_info [ 'chrslot' ] @property def account_info ( self ): return self . _account_info @property def database_config ( self ): return self . _database_config @property def account_id ( self ): return self . _account_id # Primary Key; DO NOT set @property def username ( self ): return self . _username @username.setter def username ( self , new_name ): self . set_stat_by_column ( \"name\" , new_name ) self . _username = new_name @property def logged_in ( self ): return self . _logged_in @logged_in.setter def logged_in ( self , value ): self . set_stat_by_column ( \"loggedin\" , value ) # Use with caution! self . _logged_in = value @property def banned ( self ): return self . _banned @banned.setter def banned ( self , value ): self . set_stat_by_column ( \"banned\" , value ) # Use with caution! self . _banned = value @property def ban_reason ( self ): return self . _ban_reason @ban_reason.setter def ban_reason ( self , value ): self . set_stat_by_column ( \"banreason\" , value ) self . _ban_reason = value @property def nx ( self ): return self . _nx @nx.setter def nx ( self , value ): self . set_stat_by_column ( \"nxCash\" , value ) self . _nx = value def add_nx ( self , amount ): \"\"\"Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool \"\"\" new_nx = int ( amount ) + self . nx self . nx = new_nx @property def maple_points ( self ): return self . _nx @maple_points.setter def maple_points ( self , value ): self . set_stat_by_column ( \"mPoints\" , value ) self . _maple_points = value def add_maple_points ( self , amount ): \"\"\"Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool \"\"\" new_maple_points = int ( amount ) + self . maple_points self . maple_points = new_maple_points @property def vp ( self ): return self . _vp @vp.setter def vp ( self , value ): self . set_stat_by_column ( \"vpoints\" , value ) self . _vp = value def add_vp ( self , amount ): \"\"\"Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count \"\"\" new_vp = int ( amount ) + self . vp self . vp = new_vp @property def dp ( self ): return self . _dp @dp.setter def dp ( self , value ): self . set_stat_by_column ( \"realcash\" , value ) self . _dp = value def add_dp ( self , amount ): \"\"\"Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count \"\"\" new_dp = int ( amount ) + self . dp self . dp = new_dp @property def char_slots ( self ): return self . _char_slots @char_slots.setter def char_slots ( self , value ): self . set_stat_by_column ( \"chrslot\" , value ) self . _char_slots = value def add_char_slots ( self , amount ): \"\"\"Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count \"\"\" new_count = int ( amount ) + self . char_slots self . char_slots = new_count def is_online ( self ): \"\"\"Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account \"\"\" if int ( self . logged_in ) > 0 : return True return False def unstuck ( self ): \"\"\"Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \"logged in\" \"\"\" self . logged_in = 0 def change_password ( self , new_pass ): \"\"\"Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default, therefore this function is technically functional. As \"safe\" as any website registration or auto register. Args: new_pass: string, representing the new password \"\"\" self . set_stat_by_column ( \"password\" , new_pass ) def get_stat_by_column ( self , column ): \"\"\"Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure \"\"\" try : return self . account_info [ str ( column )] except Exception as e : print ( \"[ERROR] Error trying to obtain the given column for table users.\" , e ) def set_stat_by_column ( self , column , value ): \"\"\"Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE accounts SET {column} = '{value}' WHERE id = '{self.account_id}'\" ) database . commit () print ( f \"Successfully updated {column} value for user id: {self.account_id}.\" ) self . _account_info [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False Classes Account class Account ( account_info , database_config ) Account object; models AzureMS accounts. Using instance method Lazuli::get_account_by_username(username) or the Lazuli::get_char_by_name(name).account getter will create an Account object instance with attributes identical to the account with username \"username\" (or IGN \"name\" for the latter) in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: account_id: Integer, representing Primary Key for account - Do NOT set manually username: String, representing account username; varchar(64) logged_in: Integer, represents login status of the account; int(1) and not bool for some reason banned: Integer, represents ban status of the account; int(1) and not bool for some reason ban_reason: String, representing account ban reason; text nx: Integer, representing the amount of NX Prepaid the user has maple_points: Integer, representing the amount of Maple Points the user has vp:Integer, representing the amount of Vote Points the user has dp: Integer, representing the amount of Donation Points the user has char_slots: Integer, representing the number of character slots the user has View Source class Account : \"\"\"Account object; models AzureMS accounts. Using instance method Lazuli::get_account_by_username(username) or the Lazuli::get_char_by_name(name).account getter will create an Account object instance with attributes identical to the account with username \" username \" (or IGN \" name \" for the latter) in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: account_id: Integer, representing Primary Key for account - Do NOT set manually username: String, representing account username; varchar(64) logged_in: Integer, represents login status of the account; int(1) and not bool for some reason banned: Integer, represents ban status of the account; int(1) and not bool for some reason ban_reason: String, representing account ban reason; text nx: Integer, representing the amount of NX Prepaid the user has maple_points: Integer, representing the amount of Maple Points the user has vp:Integer, representing the amount of Vote Points the user has dp: Integer, representing the amount of Donation Points the user has char_slots: Integer, representing the number of character slots the user has \"\"\" def __init__ ( self , account_info , database_config ) : \"\"\"Emulates how account object is handled server-sided Args: account_info: dictionary of user attributes, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _account_info = account_info self . _database_config = database_config self . _account_id = 0 # Primary Key - Do NOT set self . _username = \"\" # varchar ( 64 ) self . _logged_in = 0 # int ( 1 ) and not bool for some reason self . _banned = 0 # int ( 1 ) and not bool for some reason self . _ban_reason = \"\" # text # self . _gm = 0 # There are conflicting values in character and accounts - ignored for now self . _nx = 0 self . _maple_points = 0 self . _vp = 0 self . _dp = 0 self . _char_slots = 0 self . init_account_stats () def init_account_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account::__init__(account_info, database_config). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance. \"\"\" self . _account_id = self . _account_info [ 'id' ] self . _username = self . _account_info [ 'name' ] self . _logged_in = self . _account_info [ 'loggedin' ] self . _banned = self . _account_info [ 'banned' ] self . _ban_reason = self . _account_info [ 'banreason' ] # self . _gm = self . _account_info [ 'gm' ] # There are conflicting values in character and accounts - ignored for now self . _nx = self . _account_info [ 'nxCash' ] self . _maple_points = self . _account_info [ 'mPoints' ] self . _vp = self . _account_info [ 'vpoints' ] self . _dp = self . _account_info [ 'realcash' ] # Best guess - Might be wrong ! self . _char_slots = self . _account_info [ 'chrslot' ] @property def account_info ( self ) : return self . _account_info @property def database_config ( self ) : return self . _database_config @property def account_id ( self ) : return self . _account_id # Primary Key ; DO NOT set @property def username ( self ) : return self . _username @username . setter def username ( self , new_name ) : self . set_stat_by_column ( \"name\" , new_name ) self . _username = new_name @property def logged_in ( self ) : return self . _logged_in @logged_in . setter def logged_in ( self , value ) : self . set_stat_by_column ( \"loggedin\" , value ) # Use with caution ! self . _logged_in = value @property def banned ( self ) : return self . _banned @banned . setter def banned ( self , value ) : self . set_stat_by_column ( \"banned\" , value ) # Use with caution ! self . _banned = value @property def ban_reason ( self ) : return self . _ban_reason @ban_reason . setter def ban_reason ( self , value ) : self . set_stat_by_column ( \"banreason\" , value ) self . _ban_reason = value @property def nx ( self ) : return self . _nx @nx . setter def nx ( self , value ) : self . set_stat_by_column ( \"nxCash\" , value ) self . _nx = value def add_nx ( self , amount ) : \"\"\"Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool \"\"\" new_nx = int ( amount ) + self . nx self . nx = new_nx @property def maple_points ( self ) : return self . _nx @maple_points . setter def maple_points ( self , value ) : self . set_stat_by_column ( \"mPoints\" , value ) self . _maple_points = value def add_maple_points ( self , amount ) : \"\"\"Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool \"\"\" new_maple_points = int ( amount ) + self . maple_points self . maple_points = new_maple_points @property def vp ( self ) : return self . _vp @vp . setter def vp ( self , value ) : self . set_stat_by_column ( \"vpoints\" , value ) self . _vp = value def add_vp ( self , amount ) : \"\"\"Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count \"\"\" new_vp = int ( amount ) + self . vp self . vp = new_vp @property def dp ( self ) : return self . _dp @dp . setter def dp ( self , value ) : self . set_stat_by_column ( \"realcash\" , value ) self . _dp = value def add_dp ( self , amount ) : \"\"\"Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count \"\"\" new_dp = int ( amount ) + self . dp self . dp = new_dp @property def char_slots ( self ) : return self . _char_slots @char_slots . setter def char_slots ( self , value ) : self . set_stat_by_column ( \"chrslot\" , value ) self . _char_slots = value def add_char_slots ( self , amount ) : \"\"\"Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count \"\"\" new_count = int ( amount ) + self . char_slots self . char_slots = new_count def is_online ( self ) : \"\"\"Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account \"\"\" if int ( self . logged_in ) > 0 : return True return False def unstuck ( self ) : \"\"\"Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \" logged in \" \"\"\" self . logged_in = 0 def change_password ( self , new_pass ) : \"\"\"Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default, therefore this function is technically functional. As \" safe \" as any website registration or auto register. Args: new_pass: string, representing the new password \"\"\" self . set_stat_by_column ( \"password\" , new_pass ) def get_stat_by_column ( self , column ) : \"\"\"Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure \"\"\" try : return self . account_info [ str(column) ] except Exception as e : print ( \"[ERROR] Error trying to obtain the given column for table users.\" , e ) def set_stat_by_column ( self , column , value ) : \"\"\"Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE accounts SET {column} = '{value}' WHERE id = '{self.account_id}'\" ) database . commit () print ( f \"Successfully updated {column} value for user id: {self.account_id}.\" ) self . _account_info [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False Instance variables account_id account_info ban_reason banned char_slots database_config dp logged_in maple_points nx username vp Methods add_char_slots def add_char_slots ( self , amount ) Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count View Source def add_char_slots ( self , amount ): \"\"\"Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count \"\"\" new_count = int ( amount ) + self . char_slots self . char_slots = new_count add_dp def add_dp ( self , amount ) Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count View Source def add_dp ( self , amount ): \"\"\"Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count \"\"\" new_dp = int ( amount ) + self . dp self . dp = new_dp add_maple_points def add_maple_points ( self , amount ) Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool View Source def add_maple_points ( self , amount ): \"\"\"Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool \"\"\" new_maple_points = int ( amount ) + self . maple_points self . maple_points = new_maple_points add_nx def add_nx ( self , amount ) Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool View Source def add_nx ( self , amount ): \"\"\"Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool \"\"\" new_nx = int ( amount ) + self . nx self . nx = new_nx add_vp def add_vp ( self , amount ) Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count View Source def add_vp ( self , amount ): \"\"\"Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count \"\"\" new_vp = int ( amount ) + self . vp self . vp = new_vp change_password def change_password ( self , new_pass ) Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default, therefore this function is technically functional. As \"safe\" as any website registration or auto register. Args: new_pass: string, representing the new password View Source def change_password ( self , new_pass ) : \"\"\"Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default , therefore this function is technically functional . As \"safe\" as any website registration or auto register . Args: new_pass: string , representing the new password \"\"\" self . set_stat_by_column ( \"password\" , new_pass ) get_stat_by_column def get_stat_by_column ( self , column ) Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure View Source def get_stat_by_column ( self , column ) : \"\"\"Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure \"\"\" try : return self . account_info [ str(column) ] except Exception as e : print ( \"[ERROR] Error trying to obtain the given column for table users.\" , e ) init_account_stats def init_account_stats ( self ) Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account:: init (account_info, database_config). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance. View Source def init_account_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account :: __init__ ( account_info , database_config ). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance . \"\"\" self . _account_id = self . _account_info [' id '] self . _username = self . _account_info [' name '] self . _logged_in = self . _account_info [' loggedin '] self . _banned = self . _account_info [' banned '] self . _ban_reason = self . _account_info [' banreason '] # self . _gm = self . _account_info [' gm '] # There are conflicting values in character and accounts - ignored for now self . _nx = self . _account_info [' nxCash '] self . _maple_points = self . _account_info [' mPoints '] self . _vp = self . _account_info [' vpoints '] self . _dp = self . _account_info [' realcash '] # Best guess - Might be wrong ! self . _char_slots = self . _account_info [' chrslot '] is_online def is_online ( self ) Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account View Source def is_online ( self ): \"\"\"Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account \"\"\" if int ( self . logged_in ) > 0 : return True return False set_stat_by_column def set_stat_by_column ( self , column , value ) Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name View Source def set_stat_by_column ( self , column , value ) : \"\"\"Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE accounts SET {column} = '{value}' WHERE id = '{self.account_id}'\" ) database . commit () print ( f \"Successfully updated {column} value for user id: {self.account_id}.\" ) self . _account_info [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False unstuck def unstuck ( self ) Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \"logged in\" View Source def unstuck ( self ): \"\"\"Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \" logged in \" \"\"\" self . logged_in = 0","title":"Account"},{"location":"reference/lazuli/account/#module-lazuliaccount","text":"This module holds the Account class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the Account class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql.connector as con class Account : \"\"\"Account object; models AzureMS accounts. Using instance method Lazuli::get_account_by_username(username) or the Lazuli::get_char_by_name(name).account getter will create an Account object instance with attributes identical to the account with username \"username\" (or IGN \"name\" for the latter) in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: account_id: Integer, representing Primary Key for account - Do NOT set manually username: String, representing account username; varchar(64) logged_in: Integer, represents login status of the account; int(1) and not bool for some reason banned: Integer, represents ban status of the account; int(1) and not bool for some reason ban_reason: String, representing account ban reason; text nx: Integer, representing the amount of NX Prepaid the user has maple_points: Integer, representing the amount of Maple Points the user has vp:Integer, representing the amount of Vote Points the user has dp: Integer, representing the amount of Donation Points the user has char_slots: Integer, representing the number of character slots the user has \"\"\" def __init__ ( self , account_info , database_config ): \"\"\"Emulates how account object is handled server-sided Args: account_info: dictionary of user attributes, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _account_info = account_info self . _database_config = database_config self . _account_id = 0 # Primary Key - Do NOT set self . _username = \"\" # varchar(64) self . _logged_in = 0 # int(1) and not bool for some reason self . _banned = 0 # int(1) and not bool for some reason self . _ban_reason = \"\" # text # self._gm = 0 # There are conflicting values in character and accounts - ignored for now self . _nx = 0 self . _maple_points = 0 self . _vp = 0 self . _dp = 0 self . _char_slots = 0 self . init_account_stats () def init_account_stats ( self ): \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account::__init__(account_info, database_config). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance. \"\"\" self . _account_id = self . _account_info [ 'id' ] self . _username = self . _account_info [ 'name' ] self . _logged_in = self . _account_info [ 'loggedin' ] self . _banned = self . _account_info [ 'banned' ] self . _ban_reason = self . _account_info [ 'banreason' ] # self._gm = self._account_info['gm'] # There are conflicting values in character and accounts - ignored for now self . _nx = self . _account_info [ 'nxCash' ] self . _maple_points = self . _account_info [ 'mPoints' ] self . _vp = self . _account_info [ 'vpoints' ] self . _dp = self . _account_info [ 'realcash' ] # Best guess - Might be wrong! self . _char_slots = self . _account_info [ 'chrslot' ] @property def account_info ( self ): return self . _account_info @property def database_config ( self ): return self . _database_config @property def account_id ( self ): return self . _account_id # Primary Key; DO NOT set @property def username ( self ): return self . _username @username.setter def username ( self , new_name ): self . set_stat_by_column ( \"name\" , new_name ) self . _username = new_name @property def logged_in ( self ): return self . _logged_in @logged_in.setter def logged_in ( self , value ): self . set_stat_by_column ( \"loggedin\" , value ) # Use with caution! self . _logged_in = value @property def banned ( self ): return self . _banned @banned.setter def banned ( self , value ): self . set_stat_by_column ( \"banned\" , value ) # Use with caution! self . _banned = value @property def ban_reason ( self ): return self . _ban_reason @ban_reason.setter def ban_reason ( self , value ): self . set_stat_by_column ( \"banreason\" , value ) self . _ban_reason = value @property def nx ( self ): return self . _nx @nx.setter def nx ( self , value ): self . set_stat_by_column ( \"nxCash\" , value ) self . _nx = value def add_nx ( self , amount ): \"\"\"Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool \"\"\" new_nx = int ( amount ) + self . nx self . nx = new_nx @property def maple_points ( self ): return self . _nx @maple_points.setter def maple_points ( self , value ): self . set_stat_by_column ( \"mPoints\" , value ) self . _maple_points = value def add_maple_points ( self , amount ): \"\"\"Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool \"\"\" new_maple_points = int ( amount ) + self . maple_points self . maple_points = new_maple_points @property def vp ( self ): return self . _vp @vp.setter def vp ( self , value ): self . set_stat_by_column ( \"vpoints\" , value ) self . _vp = value def add_vp ( self , amount ): \"\"\"Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count \"\"\" new_vp = int ( amount ) + self . vp self . vp = new_vp @property def dp ( self ): return self . _dp @dp.setter def dp ( self , value ): self . set_stat_by_column ( \"realcash\" , value ) self . _dp = value def add_dp ( self , amount ): \"\"\"Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count \"\"\" new_dp = int ( amount ) + self . dp self . dp = new_dp @property def char_slots ( self ): return self . _char_slots @char_slots.setter def char_slots ( self , value ): self . set_stat_by_column ( \"chrslot\" , value ) self . _char_slots = value def add_char_slots ( self , amount ): \"\"\"Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count \"\"\" new_count = int ( amount ) + self . char_slots self . char_slots = new_count def is_online ( self ): \"\"\"Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account \"\"\" if int ( self . logged_in ) > 0 : return True return False def unstuck ( self ): \"\"\"Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \"logged in\" \"\"\" self . logged_in = 0 def change_password ( self , new_pass ): \"\"\"Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default, therefore this function is technically functional. As \"safe\" as any website registration or auto register. Args: new_pass: string, representing the new password \"\"\" self . set_stat_by_column ( \"password\" , new_pass ) def get_stat_by_column ( self , column ): \"\"\"Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure \"\"\" try : return self . account_info [ str ( column )] except Exception as e : print ( \"[ERROR] Error trying to obtain the given column for table users.\" , e ) def set_stat_by_column ( self , column , value ): \"\"\"Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE accounts SET {column} = '{value}' WHERE id = '{self.account_id}'\" ) database . commit () print ( f \"Successfully updated {column} value for user id: {self.account_id}.\" ) self . _account_info [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False","title":"Module lazuli.account"},{"location":"reference/lazuli/account/#classes","text":"","title":"Classes"},{"location":"reference/lazuli/account/#account","text":"class Account ( account_info , database_config ) Account object; models AzureMS accounts. Using instance method Lazuli::get_account_by_username(username) or the Lazuli::get_char_by_name(name).account getter will create an Account object instance with attributes identical to the account with username \"username\" (or IGN \"name\" for the latter) in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: account_id: Integer, representing Primary Key for account - Do NOT set manually username: String, representing account username; varchar(64) logged_in: Integer, represents login status of the account; int(1) and not bool for some reason banned: Integer, represents ban status of the account; int(1) and not bool for some reason ban_reason: String, representing account ban reason; text nx: Integer, representing the amount of NX Prepaid the user has maple_points: Integer, representing the amount of Maple Points the user has vp:Integer, representing the amount of Vote Points the user has dp: Integer, representing the amount of Donation Points the user has char_slots: Integer, representing the number of character slots the user has View Source class Account : \"\"\"Account object; models AzureMS accounts. Using instance method Lazuli::get_account_by_username(username) or the Lazuli::get_char_by_name(name).account getter will create an Account object instance with attributes identical to the account with username \" username \" (or IGN \" name \" for the latter) in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: account_id: Integer, representing Primary Key for account - Do NOT set manually username: String, representing account username; varchar(64) logged_in: Integer, represents login status of the account; int(1) and not bool for some reason banned: Integer, represents ban status of the account; int(1) and not bool for some reason ban_reason: String, representing account ban reason; text nx: Integer, representing the amount of NX Prepaid the user has maple_points: Integer, representing the amount of Maple Points the user has vp:Integer, representing the amount of Vote Points the user has dp: Integer, representing the amount of Donation Points the user has char_slots: Integer, representing the number of character slots the user has \"\"\" def __init__ ( self , account_info , database_config ) : \"\"\"Emulates how account object is handled server-sided Args: account_info: dictionary of user attributes, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _account_info = account_info self . _database_config = database_config self . _account_id = 0 # Primary Key - Do NOT set self . _username = \"\" # varchar ( 64 ) self . _logged_in = 0 # int ( 1 ) and not bool for some reason self . _banned = 0 # int ( 1 ) and not bool for some reason self . _ban_reason = \"\" # text # self . _gm = 0 # There are conflicting values in character and accounts - ignored for now self . _nx = 0 self . _maple_points = 0 self . _vp = 0 self . _dp = 0 self . _char_slots = 0 self . init_account_stats () def init_account_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account::__init__(account_info, database_config). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance. \"\"\" self . _account_id = self . _account_info [ 'id' ] self . _username = self . _account_info [ 'name' ] self . _logged_in = self . _account_info [ 'loggedin' ] self . _banned = self . _account_info [ 'banned' ] self . _ban_reason = self . _account_info [ 'banreason' ] # self . _gm = self . _account_info [ 'gm' ] # There are conflicting values in character and accounts - ignored for now self . _nx = self . _account_info [ 'nxCash' ] self . _maple_points = self . _account_info [ 'mPoints' ] self . _vp = self . _account_info [ 'vpoints' ] self . _dp = self . _account_info [ 'realcash' ] # Best guess - Might be wrong ! self . _char_slots = self . _account_info [ 'chrslot' ] @property def account_info ( self ) : return self . _account_info @property def database_config ( self ) : return self . _database_config @property def account_id ( self ) : return self . _account_id # Primary Key ; DO NOT set @property def username ( self ) : return self . _username @username . setter def username ( self , new_name ) : self . set_stat_by_column ( \"name\" , new_name ) self . _username = new_name @property def logged_in ( self ) : return self . _logged_in @logged_in . setter def logged_in ( self , value ) : self . set_stat_by_column ( \"loggedin\" , value ) # Use with caution ! self . _logged_in = value @property def banned ( self ) : return self . _banned @banned . setter def banned ( self , value ) : self . set_stat_by_column ( \"banned\" , value ) # Use with caution ! self . _banned = value @property def ban_reason ( self ) : return self . _ban_reason @ban_reason . setter def ban_reason ( self , value ) : self . set_stat_by_column ( \"banreason\" , value ) self . _ban_reason = value @property def nx ( self ) : return self . _nx @nx . setter def nx ( self , value ) : self . set_stat_by_column ( \"nxCash\" , value ) self . _nx = value def add_nx ( self , amount ) : \"\"\"Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool \"\"\" new_nx = int ( amount ) + self . nx self . nx = new_nx @property def maple_points ( self ) : return self . _nx @maple_points . setter def maple_points ( self , value ) : self . set_stat_by_column ( \"mPoints\" , value ) self . _maple_points = value def add_maple_points ( self , amount ) : \"\"\"Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool \"\"\" new_maple_points = int ( amount ) + self . maple_points self . maple_points = new_maple_points @property def vp ( self ) : return self . _vp @vp . setter def vp ( self , value ) : self . set_stat_by_column ( \"vpoints\" , value ) self . _vp = value def add_vp ( self , amount ) : \"\"\"Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count \"\"\" new_vp = int ( amount ) + self . vp self . vp = new_vp @property def dp ( self ) : return self . _dp @dp . setter def dp ( self , value ) : self . set_stat_by_column ( \"realcash\" , value ) self . _dp = value def add_dp ( self , amount ) : \"\"\"Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count \"\"\" new_dp = int ( amount ) + self . dp self . dp = new_dp @property def char_slots ( self ) : return self . _char_slots @char_slots . setter def char_slots ( self , value ) : self . set_stat_by_column ( \"chrslot\" , value ) self . _char_slots = value def add_char_slots ( self , amount ) : \"\"\"Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count \"\"\" new_count = int ( amount ) + self . char_slots self . char_slots = new_count def is_online ( self ) : \"\"\"Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account \"\"\" if int ( self . logged_in ) > 0 : return True return False def unstuck ( self ) : \"\"\"Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \" logged in \" \"\"\" self . logged_in = 0 def change_password ( self , new_pass ) : \"\"\"Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default, therefore this function is technically functional. As \" safe \" as any website registration or auto register. Args: new_pass: string, representing the new password \"\"\" self . set_stat_by_column ( \"password\" , new_pass ) def get_stat_by_column ( self , column ) : \"\"\"Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure \"\"\" try : return self . account_info [ str(column) ] except Exception as e : print ( \"[ERROR] Error trying to obtain the given column for table users.\" , e ) def set_stat_by_column ( self , column , value ) : \"\"\"Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE accounts SET {column} = '{value}' WHERE id = '{self.account_id}'\" ) database . commit () print ( f \"Successfully updated {column} value for user id: {self.account_id}.\" ) self . _account_info [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False","title":"Account"},{"location":"reference/lazuli/account/#instance-variables","text":"account_id account_info ban_reason banned char_slots database_config dp logged_in maple_points nx username vp","title":"Instance variables"},{"location":"reference/lazuli/account/#methods","text":"","title":"Methods"},{"location":"reference/lazuli/account/#add_char_slots","text":"def add_char_slots ( self , amount ) Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count View Source def add_char_slots ( self , amount ): \"\"\"Adds the specified amount to the current character slot count Args: amount: Int, representing the number of slots to be added to the current count \"\"\" new_count = int ( amount ) + self . char_slots self . char_slots = new_count","title":"add_char_slots"},{"location":"reference/lazuli/account/#add_dp","text":"def add_dp ( self , amount ) Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count View Source def add_dp ( self , amount ): \"\"\"Adds the specified amount to the current DP count Args: amount: Int, representing the number of DPs to be added to the current count \"\"\" new_dp = int ( amount ) + self . dp self . dp = new_dp","title":"add_dp"},{"location":"reference/lazuli/account/#add_maple_points","text":"def add_maple_points ( self , amount ) Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool View Source def add_maple_points ( self , amount ): \"\"\"Adds the specified amount to the current Maple Points pool Args: amount: Int, representing the number of Maple Points to be added to the current pool \"\"\" new_maple_points = int ( amount ) + self . maple_points self . maple_points = new_maple_points","title":"add_maple_points"},{"location":"reference/lazuli/account/#add_nx","text":"def add_nx ( self , amount ) Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool View Source def add_nx ( self , amount ): \"\"\"Adds the specified amount to the current NX pool Args: amount: Int, representing the amount of NX to be added to the NX pool \"\"\" new_nx = int ( amount ) + self . nx self . nx = new_nx","title":"add_nx"},{"location":"reference/lazuli/account/#add_vp","text":"def add_vp ( self , amount ) Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count View Source def add_vp ( self , amount ): \"\"\"Adds the specified amount to the current VP count Args: amount: Int, representing the number of vote points to be added to the current count \"\"\" new_vp = int ( amount ) + self . vp self . vp = new_vp","title":"add_vp"},{"location":"reference/lazuli/account/#change_password","text":"def change_password ( self , new_pass ) Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default, therefore this function is technically functional. As \"safe\" as any website registration or auto register. Args: new_pass: string, representing the new password View Source def change_password ( self , new_pass ) : \"\"\"Changes the current password to the given one. WARNING: INHERENTLY UNSAFE Azure316 does not hash passwords by default , therefore this function is technically functional . As \"safe\" as any website registration or auto register . Args: new_pass: string , representing the new password \"\"\" self . set_stat_by_column ( \"password\" , new_pass )","title":"change_password"},{"location":"reference/lazuli/account/#get_stat_by_column","text":"def get_stat_by_column ( self , column ) Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure View Source def get_stat_by_column ( self , column ) : \"\"\"Fetches account attribute by column name Returns: Int or String, representing user attribute queried Raises: Generic error on failure \"\"\" try : return self . account_info [ str(column) ] except Exception as e : print ( \"[ERROR] Error trying to obtain the given column for table users.\" , e )","title":"get_stat_by_column"},{"location":"reference/lazuli/account/#init_account_stats","text":"def init_account_stats ( self ) Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account:: init (account_info, database_config). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance. View Source def init_account_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Account object's attributes Runs near the end of Account :: __init__ ( account_info , database_config ). It assigns the account attributes in account_info to their respective protected attributes belonging to the Account object instance . \"\"\" self . _account_id = self . _account_info [' id '] self . _username = self . _account_info [' name '] self . _logged_in = self . _account_info [' loggedin '] self . _banned = self . _account_info [' banned '] self . _ban_reason = self . _account_info [' banreason '] # self . _gm = self . _account_info [' gm '] # There are conflicting values in character and accounts - ignored for now self . _nx = self . _account_info [' nxCash '] self . _maple_points = self . _account_info [' mPoints '] self . _vp = self . _account_info [' vpoints '] self . _dp = self . _account_info [' realcash '] # Best guess - Might be wrong ! self . _char_slots = self . _account_info [' chrslot ']","title":"init_account_stats"},{"location":"reference/lazuli/account/#is_online","text":"def is_online ( self ) Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account View Source def is_online ( self ): \"\"\"Checks if the 'loggedin' column is greater than 0 (they are online if > 0) Returns: Boolean, representing the online status of the account \"\"\" if int ( self . logged_in ) > 0 : return True return False","title":"is_online"},{"location":"reference/lazuli/account/#set_stat_by_column","text":"def set_stat_by_column ( self , column , value ) Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name View Source def set_stat_by_column ( self , column , value ) : \"\"\"Sets a account's attributes by column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in the accounts table, with the provided value. Not recommended to use this alone, as it won't update the account object which this was used from Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful. Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE accounts SET {column} = '{value}' WHERE id = '{self.account_id}'\" ) database . commit () print ( f \"Successfully updated {column} value for user id: {self.account_id}.\" ) self . _account_info [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False","title":"set_stat_by_column"},{"location":"reference/lazuli/account/#unstuck","text":"def unstuck ( self ) Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \"logged in\" View Source def unstuck ( self ): \"\"\"Sets loggedin column in database to 0 This unstucks the account as server checks loggedin value to decided whether they are \" logged in \" \"\"\" self . logged_in = 0","title":"unstuck"},{"location":"reference/lazuli/character/","text":"Module lazuli.character This module holds the Character class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the Character class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql . connector as con from lazuli import JOBS from lazuli . inventory import Inventory from lazuli . account import Account import lazuli . utility as utils class Character : \"\"\"Character object; models AzureMS characters. Using instance method Lazuli::get_char_by_name(name) will create a Character object instance with attributes identical to the character with IGN \" name \" in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: character_id: Integer, representing Primary Key for Character; int(11) account_id: Integer, representing Primary Key for Account (FK); int(11) name: String, representing Character IGN; varchar(13) level: Integer, representing Character level exp: Integer, representing Character EXP; bigint(20) strength: Integer, representing Character STR stat pool dex: Integer, representing Character DEX stat pool luk: Integer, representing Character LUK stat pool inte: Integer, representing Character INT stat pool max_hp: Integer, representing Character Max HP stat pool max_mp: Integer, representing Character Max MP stat pool meso: Integer, representing character wealth (aka Meso count) job: Integer, representing Job ID of the character skin: Integer, representing Skin ID of the character gender: Integer, representing Gender ID of the character fame: Integer, representing Character fame count hair: Integer, representing Hair ID of the character face: Integer, representing Face ID of the character ap: Integer, representing Character free Ability Points (AP) pool map: Integer, representing Map ID of the map that the character is currently in bl_slots: Integer, representing Character Buddy List slots rebirths: Integer, representing Character rebirth count ambition: Integer, representing Character Ambition pool insight: Integer, representing Character Insight pool willpower: Integer, representing Character Willpower pool diligence: Integer, representing Character Diligence pool empathy: Integer, representing Character Empathy pool charm: Integer, representing Character Charm pool honour: Integer, representing Character Honour pool mute: String, representing whether a character is chat-banned \"\"\" def __ init__ ( self , char_stats , database_config ) : \"\"\"Emulates how character object is handled server-sided Not all character attributes are inherited, as the database table design in AzureMS is quite verbose Args: char_stats: dictionary of character stats, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _ stats = char_stats self . _ database_config = database_config self . _ character_id = 0 self . _ account_id = 0 self . _ name = \"\" # varchar 13 self . _ level = 0 self . _ exp = 0 self . _ strength = 0 self . _ dex = 0 self . _ luk = 0 self . _ inte = 0 self . _ max_hp = 0 self . _ max_mp = 0 self . _ meso = 0 self . _ job = 0 self . _ skin = 0 self . _ gender = 0 self . _ fame = 0 self . _ hair = 0 self . _ face = 0 self . _ ap = 0 self . _ map = 0 self . _ bl_slots = 0 self . _ rebirths = 0 self . _ ambition = 0 self . _ insight = 0 self . _ willpower = 0 self . _ diligence = 0 self . _ empathy = 0 self . _ charm = 0 self . _ honour = 0 self . _ mute = \"\" # Takes lower case true / false but is a varchar ( 45 ) and not a Bool self . init_stats () # Assign instance variables # Create Inventory object instance via class constructor , using details from Character object instance self . _ inventory = self . init_inventory () # Create Account object instance via class constructor , using details from Character object instance self . _ account = self . init_account () # fill with attributes from init def init_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character::__init__(char_stats, database_config). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance. \"\"\" self . _ character_id = self . _ stats [ 'id' ] self . _ account_id = self . _ stats [ 'accountid' ] self . _ name = self . _ stats [ 'name' ] self . _ level = self . _ stats [ 'level' ] self . _ exp = self . _ stats [ 'exp' ] self . _ strength = self . _ stats [ 'str' ] self . _ dex = self . _ stats [ 'dex' ] self . _ luk = self . _ stats [ 'luk' ] self . _ inte = self . _ stats [ 'int' ] self . _ max_hp = self . _ stats [ 'maxhp' ] self . _ max_mp = self . _ stats [ 'maxmp' ] self . _ meso = self . _ stats [ 'meso' ] self . _ job = self . _ stats [ 'job' ] self . _ skin = self . _ stats [ 'skincolor' ] self . _ gender = self . _ stats [ 'gender' ] self . _ fame = self . _ stats [ 'fame' ] self . _ hair = self . _ stats [ 'hair' ] self . _ face = self . _ stats [ 'face' ] self . _ ap = self . _ stats [ 'ap' ] self . _ map = self . _ stats [ 'map' ] self . _ bl_slots = self . _ stats [ 'buddyCapacity' ] self . _ rebirths = self . _ stats [ 'reborns' ] self . _ ambition = self . _ stats [ 'ambition' ] self . _ insight = self . _ stats [ 'insight' ] self . _ willpower = self . _ stats [ 'willpower' ] self . _ diligence = self . _ stats [ 'diligence' ] self . _ empathy = self . _ stats [ 'empathy' ] self . _ charm = self . _ stats [ 'charm' ] self . _ honour = self . _ stats [ 'innerExp' ] # Best guess - might be wrong ! self . _ mute = self . _ stats [ 'chatban' ] def init_account ( self ) : \"\"\"Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character::__init__(char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" account_id = utils . get_db_first_hit ( self . _ database_config , f \"SELECT * FROM characters WHERE id = '{self.character_id}'\" ). get ( \"accountid\" ) # get_db () returns a Dictionary , so get () is used to fetch only the value # The row will always be 0 because there should be no characters with the same character ID ( Primary Key ) account_info = utils . get_db_first_hit ( self . _ database_config , f \"SELECT * FROM accounts WHERE id = '{account_id}'\" ) # The row will always be 0 because there should be no characters with the same account ID ( Primary Key ) account = Account ( account_info , self . database_config ) return account def init_inventory ( self ) : \"\"\"Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character::__init__(char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" inventory = Inventory ( self . character_id , self . database_config ) return inventory @property def database_config ( self ) : return self . _ database_config @property def stats ( self ) : return self . _ stats @property def character_id ( self ) : return self . _ character_id # Only getter , no setter ; Primary Key must not be set manually ! @property def account_id ( self ) : return self . _ account_id # Only getter , no setter ; Primary Key must not be set manually ! @property def level ( self ) : return self . _ level @level . setter def level ( self , x ) : if x > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else : self . set_stat_by_column ( \"level\" , x ) self . _ level = x def add_level ( self , amount ) : \"\"\"Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count \"\"\" new_level = int ( self . level ) + amount if new_level > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else : self . level = new_level @property def job ( self ) : return self . _ job @job . setter def job ( self , job_id ) : if str ( job_id ) not in JOBS : raise ValueError ( \"Invalid Job ID!\" ) else : self . set_stat_by_column ( \"job\" , job_id ) self . _ job = job_id def get_job_name ( self ) : \"\"\"Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID \"\"\" return JOBS [ str ( self . job )] @property def name ( self ) : return self . _ name @name . setter def name ( self , new_name ) : \"\"\"Set a new name for the character Args: new_name: string, representing the new character name that will be set in the database \"\"\" if len ( new_name ) > 13 : raise ValueError ( \"Character names can only be 13 characters long!\" ) else : self . set_stat_by_column ( \"name\" , new_name ) self . _ name = new_name @property def meso ( self ) : return self . _ meso @meso . setter def meso ( self , amount ) : if amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else : self . set_stat_by_column ( \"meso\" , amount ) self . _ meso = amount def add_mesos ( self , amount ) : \"\"\"Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count \"\"\" new_amount = int ( self . meso ) + amount if new_amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else : self . meso = str ( new_amount ) # money is a String ; converting back to String for consistency @property def fame ( self ) : return self . _ fame @fame . setter def fame ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else : self . set_stat_by_column ( \"fame\" , amount ) self . _ fame = amount def add_fame ( self , amount ) : \"\"\"Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count \"\"\" new_fame = int ( self . fame ) + amount if new_fame > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else : self . fame = new_fame @property def map ( self ) : return self . _ map @map . setter def map ( self , map_id ) : if map_id < 100000000 or map_id > 999999999 : # Best guess - might be wrong ! raise ValueError ( \"Wrong map ID!\" ) else : self . set_stat_by_column ( \"map\" , map_id ) self . _ map = map_id @property def face ( self ) : return self . _ face @face . setter def face ( self , face_id ) : self . set_stat_by_column ( \"face\" , face_id ) # TODO : Add check self . _ face = face_id @property def hair ( self ) : return self . _ hair @hair . setter def hair ( self , hair_id ) : self . set_stat_by_column ( \"hair\" , hair_id ) # TODO : Add check self . _ hair = hair_id @property def skin ( self ) : return self . _ skin @skin . setter def skin ( self , skin_id ) : self . set_stat_by_column ( \"skin\" , skin_id ) # TODO : Add check self . _ skin = skin_id @property def gender ( self ) : return self . _ gender @gender . setter def gender ( self , gender_id ) : self . set_stat_by_column ( \"gender\" , gender_id ) # TODO : Add check self . _ gender = gender_id @property def exp ( self ) : return self . _ exp @exp . setter def exp ( self , exp_amount ) : if exp_amount > 2147483647 : raise ValueError ( \"You should not try to set EXP above 2bil!\" ) else : self . set_stat_by_column ( \"exp\" , exp_amount ) self . _ exp = exp_amount def add_exp ( self , amount ) : \"\"\"Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool \"\"\" if amount > 2147483647 : raise ValueError ( \"You should not try to increment EXP by more than 2bil!\" ) else : new_exp = int ( self . exp ) + amount self . exp = str ( new_exp ) # EXP is a String ; converting back to String for consistency @property def strength ( self ) : return self . _ strength @strength . setter def strength ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else : self . set_stat_by_column ( \"str\" , amount ) self . _ strength = amount def add_str ( self , amount ) : \"\"\"Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool \"\"\" new_str = int ( self . strength ) + amount if new_str > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else : self . strength = new_str @property def dex ( self ) : return self . _ dex @dex . setter def dex ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else : self . set_stat_by_column ( \"dex\" , amount ) self . _ dex = amount def add_dex ( self , amount ) : \"\"\"Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool \"\"\" new_dex = int ( self . dex ) + amount if new_dex > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else : self . dex = new_dex @property def inte ( self ) : return self . _ inte @inte . setter def inte ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else : self . set_stat_by_column ( \"int\" , amount ) self . _ inte = amount def add_inte ( self , amount ) : \"\"\"Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool \"\"\" new_inte = int ( self . inte ) + amount if new_inte > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else : self . inte = new_inte @property def luk ( self ) : return self . _ luk @luk . setter def luk ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else : self . set_stat_by_column ( \"luk\" , amount ) self . _ luk = amount def add_luk ( self , amount ) : \"\"\"Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool \"\"\" new_luk = int ( self . luk ) + amount if new_luk > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else : self . luk = new_luk def get_primary_stats ( self ) : \"\"\"Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats \"\"\" primary_stats = { \"str\" : self . strength , \"dex\" : self . dex , \"int\" : self . inte , \"luk\" : self . luk } return primary_stats @property def max_hp ( self ) : return self . _ max_hp @max_hp . setter def max_hp ( self , amount ) : self . set_stat_by_column ( \"maxhp\" , amount ) self . _ max_hp = amount def add_max_hp ( self , amount ) : \"\"\"Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool \"\"\" new_hp = int ( self . max_hp ) + amount self . max_hp = new_hp @property def max_mp ( self ) : return self . _ max_mp @max_mp . setter def max_mp ( self , amount ) : self . set_stat_by_column ( \"maxmp\" , amount ) self . _ max_mp = amount def add_max_mp ( self , amount ) : \"\"\"Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool \"\"\" new_mp = int ( self . max_mp ) + amount self . max_mp = new_mp @property def ap ( self ) : return self . _ ap @ap . setter def ap ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else : self . set_stat_by_column ( \"ap\" , amount ) self . _ ap = amount def add_ap ( self , amount ) : \"\"\"Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool \"\"\" new_ap = int ( self . ap ) + amount if new_ap > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else : self . ap = new_ap @property def bl_slots ( self ) : return self . _ bl_slots @bl_slots . setter def bl_slots ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"buddyCapacity\" , amount ) self . _ bl_slots = amount def add_bl_slots ( self , amount ) : # TODO : Add checks new_amount = int ( self . bl_slots ) + amount self . bl_slots = new_amount @property def rebirths ( self ) : return self . _ rebirths @rebirths . setter def rebirths ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"reborns\" , amount ) self . _ rebirths = amount def add_rebirths ( self , amount ) : # TODO : Add checks new_amount = int ( self . rebirths ) + amount self . rebirths = new_amount @property def ambition ( self ) : return self . _ ambition @ambition . setter def ambition ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"ambition\" , amount ) self . _ ambition = amount def add_ambition ( self , amount ) : # TODO : Add checks new_amount = int ( self . ambition ) + amount self . ambition = new_amount @property def insight ( self ) : return self . _ insight @insight . setter def insight ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"insight\" , amount ) self . _ insight = amount def add_insight ( self , amount ) : # TODO : Add checks new_amount = int ( self . insight ) + amount self . insight = new_amount @property def willpower ( self ) : return self . _ willpower @willpower . setter def willpower ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"willpower\" , amount ) self . _ willpower = amount def add_willpower ( self , amount ) : # TODO : Add checks new_amount = int ( self . willpower ) + amount self . willpower = new_amount @property def diligence ( self ) : return self . _ diligence @diligence . setter def diligence ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"diligence\" , amount ) self . _ diligence = amount def add_diligence ( self , amount ) : # TODO : Add checks new_amount = int ( self . diligence ) + amount self . diligence = new_amount @property def empathy ( self ) : return self . _ empathy @empathy . setter def empathy ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"empathy\" , amount ) self . _ empathy = amount def add_empathy ( self , amount ) : # TODO : Add checks new_amount = int ( self . empathy ) + amount self . empathy = new_amount @property def charm ( self ) : return self . _ charm @charm . setter def charm ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"charm\" , amount ) self . _ charm = amount def add_charm ( self , amount ) : # TODO : Add checks new_amount = int ( self . charm ) + amount self . charm = new_amount @property def honour ( self ) : return self . _ honour @honour . setter def honour ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"honour\" , amount ) self . _ honour = amount def add_honour ( self , amount ) : # TODO : Add checks new_amount = int ( self . honour ) + amount self . honour = new_amount @property def mute ( self ) : return self . _ mute @mute . setter def mute ( self , status ) : # TODO : Add checks self . set_stat_by_column ( \"mute\" , status ) self . _ mute = status @property def account ( self ) : return self . _ account @property def inventory ( self ) : return self . _ inventory def get_char_img ( self ) : \"\"\"Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar \"\"\" equipped_items = [ self . face , self . hair ] equipped_inv = self . inventory . equipped_inv for item in equipped_inv: item_id = equipped_inv [ item ][ \"itemid\" ] equipped_items . append ( item_id ) url = f \"https://maplestory.io/api/GMS/216/Character/200{self.skin}/{str(equipped_items)[1:-1]}/stand1/1\" . replace ( \" \" , \"\" ) return url def set_stat_by_column ( self , column , value ) : \"\"\"Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _ database_config [ \"host\" ] user = self . _ database_config [ \"user\" ] password = self . _ database_config [ \"password\" ] schema = self . _ database_config [ \"schema\" ] port = self . _ database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE name = '{self.name}'\" ) database . commit () print ( f \"Successfully updated {column} value for character: {self.name}.\" ) self . _ stats [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False def get_stat_by_column ( self , column ) : \"\"\"Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure \"\"\" try : return self . stats [ column ] except Exception as e : print ( \"[ERROR] Error trying to get stats from given column.\" , e ) return False Variables JOBS Classes Character class Character ( char_stats , database_config ) Character object; models AzureMS characters. Using instance method Lazuli::get_char_by_name(name) will create a Character object instance with attributes identical to the character with IGN \"name\" in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: character_id: Integer, representing Primary Key for Character; int(11) account_id: Integer, representing Primary Key for Account (FK); int(11) name: String, representing Character IGN; varchar(13) level: Integer, representing Character level exp: Integer, representing Character EXP; bigint(20) strength: Integer, representing Character STR stat pool dex: Integer, representing Character DEX stat pool luk: Integer, representing Character LUK stat pool inte: Integer, representing Character INT stat pool max_hp: Integer, representing Character Max HP stat pool max_mp: Integer, representing Character Max MP stat pool meso: Integer, representing character wealth (aka Meso count) job: Integer, representing Job ID of the character skin: Integer, representing Skin ID of the character gender: Integer, representing Gender ID of the character fame: Integer, representing Character fame count hair: Integer, representing Hair ID of the character face: Integer, representing Face ID of the character ap: Integer, representing Character free Ability Points (AP) pool map: Integer, representing Map ID of the map that the character is currently in bl_slots: Integer, representing Character Buddy List slots rebirths: Integer, representing Character rebirth count ambition: Integer, representing Character Ambition pool insight: Integer, representing Character Insight pool willpower: Integer, representing Character Willpower pool diligence: Integer, representing Character Diligence pool empathy: Integer, representing Character Empathy pool charm: Integer, representing Character Charm pool honour: Integer, representing Character Honour pool mute: String, representing whether a character is chat-banned View Source class Character: \"\"\"Character object; models AzureMS characters. Using instance method Lazuli::get_char_by_name(name) will create a Character object instance with attributes identical to the character with IGN \" name \" in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: character_id: Integer, representing Primary Key for Character; int(11) account_id: Integer, representing Primary Key for Account (FK); int(11) name: String, representing Character IGN; varchar(13) level: Integer, representing Character level exp: Integer, representing Character EXP; bigint(20) strength: Integer, representing Character STR stat pool dex: Integer, representing Character DEX stat pool luk: Integer, representing Character LUK stat pool inte: Integer, representing Character INT stat pool max_hp: Integer, representing Character Max HP stat pool max_mp: Integer, representing Character Max MP stat pool meso: Integer, representing character wealth (aka Meso count) job: Integer, representing Job ID of the character skin: Integer, representing Skin ID of the character gender: Integer, representing Gender ID of the character fame: Integer, representing Character fame count hair: Integer, representing Hair ID of the character face: Integer, representing Face ID of the character ap: Integer, representing Character free Ability Points (AP) pool map: Integer, representing Map ID of the map that the character is currently in bl_slots: Integer, representing Character Buddy List slots rebirths: Integer, representing Character rebirth count ambition: Integer, representing Character Ambition pool insight: Integer, representing Character Insight pool willpower: Integer, representing Character Willpower pool diligence: Integer, representing Character Diligence pool empathy: Integer, representing Character Empathy pool charm: Integer, representing Character Charm pool honour: Integer, representing Character Honour pool mute: String, representing whether a character is chat-banned \"\"\" def __init__ ( self , char_stats , database_config ): \"\"\"Emulates how character object is handled server-sided Not all character attributes are inherited, as the database table design in AzureMS is quite verbose Args: char_stats: dictionary of character stats, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _stats = char_stats self . _database_config = database_config self . _character_id = 0 self . _account_id = 0 self . _name = \"\" # varchar 13 self . _level = 0 self . _exp = 0 self . _strength = 0 self . _dex = 0 self . _luk = 0 self . _inte = 0 self . _max_hp = 0 self . _max_mp = 0 self . _meso = 0 self . _job = 0 self . _skin = 0 self . _gender = 0 self . _fame = 0 self . _hair = 0 self . _face = 0 self . _ap = 0 self . _map = 0 self . _bl_slots = 0 self . _rebirths = 0 self . _ambition = 0 self . _insight = 0 self . _willpower = 0 self . _diligence = 0 self . _empathy = 0 self . _charm = 0 self . _honour = 0 self . _mute = \"\" # Takes lower case true/false but is a varchar (45) and not a Bool self . init_stats () # Assign instance variables # Create Inventory object instance via class constructor, using details from Character object instance self . _inventory = self . init_inventory () # Create Account object instance via class constructor, using details from Character object instance self . _account = self . init_account () # fill with attributes from init def init_stats ( self ): \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character::__init__(char_stats, database_config). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance. \"\"\" self . _character_id = self . _stats [ 'id' ] self . _account_id = self . _stats [ 'accountid' ] self . _name = self . _stats [ 'name' ] self . _level = self . _stats [ 'level' ] self . _exp = self . _stats [ 'exp' ] self . _strength = self . _stats [ 'str' ] self . _dex = self . _stats [ 'dex' ] self . _luk = self . _stats [ 'luk' ] self . _inte = self . _stats [ 'int' ] self . _max_hp = self . _stats [ 'maxhp' ] self . _max_mp = self . _stats [ 'maxmp' ] self . _meso = self . _stats [ 'meso' ] self . _job = self . _stats [ 'job' ] self . _skin = self . _stats [ 'skincolor' ] self . _gender = self . _stats [ 'gender' ] self . _fame = self . _stats [ 'fame' ] self . _hair = self . _stats [ 'hair' ] self . _face = self . _stats [ 'face' ] self . _ap = self . _stats [ 'ap' ] self . _map = self . _stats [ 'map' ] self . _bl_slots = self . _stats [ 'buddyCapacity' ] self . _rebirths = self . _stats [ 'reborns' ] self . _ambition = self . _stats [ 'ambition' ] self . _insight = self . _stats [ 'insight' ] self . _willpower = self . _stats [ 'willpower' ] self . _diligence = self . _stats [ 'diligence' ] self . _empathy = self . _stats [ 'empathy' ] self . _charm = self . _stats [ 'charm' ] self . _honour = self . _stats [ 'innerExp' ] # Best guess - might be wrong! self . _mute = self . _stats [ 'chatban' ] def init_account ( self ): \"\"\"Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character::__init__(char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" account_id = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE id = '{self.character_id}'\" ). get ( \"accountid\" ) # get_db() returns a Dictionary, so get() is used to fetch only the value # The row will always be 0 because there should be no characters with the same character ID (Primary Key) account_info = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE id = '{account_id}'\" ) # The row will always be 0 because there should be no characters with the same account ID (Primary Key) account = Account ( account_info , self . database_config ) return account def init_inventory ( self ): \"\"\"Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character::__init__(char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" inventory = Inventory ( self . character_id , self . database_config ) return inventory @property def database_config ( self ): return self . _database_config @property def stats ( self ): return self . _stats @property def character_id ( self ): return self . _character_id # Only getter, no setter; Primary Key must not be set manually! @property def account_id ( self ): return self . _account_id # Only getter, no setter; Primary Key must not be set manually! @property def level ( self ): return self . _level @level . setter def level ( self , x ): if x > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else: self . set_stat_by_column ( \"level\" , x ) self . _level = x def add_level ( self , amount ): \"\"\"Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count \"\"\" new_level = int ( self . level ) + amount if new_level > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else: self . level = new_level @property def job ( self ): return self . _job @job . setter def job ( self , job_id ): if str ( job_id ) not in JOBS: raise ValueError ( \"Invalid Job ID!\" ) else: self . set_stat_by_column ( \"job\" , job_id ) self . _job = job_id def get_job_name ( self ): \"\"\"Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID \"\"\" return JOBS [ str ( self . job )] @property def name ( self ): return self . _name @name . setter def name ( self , new_name ): \"\"\"Set a new name for the character Args: new_name: string, representing the new character name that will be set in the database \"\"\" if len ( new_name ) > 13 : raise ValueError ( \"Character names can only be 13 characters long!\" ) else: self . set_stat_by_column ( \"name\" , new_name ) self . _name = new_name @property def meso ( self ): return self . _meso @meso . setter def meso ( self , amount ): if amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else: self . set_stat_by_column ( \"meso\" , amount ) self . _meso = amount def add_mesos ( self , amount ): \"\"\"Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count \"\"\" new_amount = int ( self . meso ) + amount if new_amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else: self . meso = str ( new_amount ) # money is a String; converting back to String for consistency @property def fame ( self ): return self . _fame @fame . setter def fame ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else: self . set_stat_by_column ( \"fame\" , amount ) self . _fame = amount def add_fame ( self , amount ): \"\"\"Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count \"\"\" new_fame = int ( self . fame ) + amount if new_fame > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else: self . fame = new_fame @property def map ( self ): return self . _map @map . setter def map ( self , map_id ): if map_id < 100000000 or map_id > 999999999 : # Best guess - might be wrong! raise ValueError ( \"Wrong map ID!\" ) else: self . set_stat_by_column ( \"map\" , map_id ) self . _map = map_id @property def face ( self ): return self . _face @face . setter def face ( self , face_id ): self . set_stat_by_column ( \"face\" , face_id ) # TODO: Add check self . _face = face_id @property def hair ( self ): return self . _hair @hair . setter def hair ( self , hair_id ): self . set_stat_by_column ( \"hair\" , hair_id ) # TODO: Add check self . _hair = hair_id @property def skin ( self ): return self . _skin @skin . setter def skin ( self , skin_id ): self . set_stat_by_column ( \"skin\" , skin_id ) # TODO: Add check self . _skin = skin_id @property def gender ( self ): return self . _gender @gender . setter def gender ( self , gender_id ): self . set_stat_by_column ( \"gender\" , gender_id ) # TODO: Add check self . _gender = gender_id @property def exp ( self ): return self . _exp @exp . setter def exp ( self , exp_amount ): if exp_amount > 2147483647 : raise ValueError ( \"You should not try to set EXP above 2bil!\" ) else: self . set_stat_by_column ( \"exp\" , exp_amount ) self . _exp = exp_amount def add_exp ( self , amount ): \"\"\"Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool \"\"\" if amount > 2147483647 : raise ValueError ( \"You should not try to increment EXP by more than 2bil!\" ) else: new_exp = int ( self . exp ) + amount self . exp = str ( new_exp ) # EXP is a String; converting back to String for consistency @property def strength ( self ): return self . _strength @strength . setter def strength ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else: self . set_stat_by_column ( \"str\" , amount ) self . _strength = amount def add_str ( self , amount ): \"\"\"Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool \"\"\" new_str = int ( self . strength ) + amount if new_str > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else: self . strength = new_str @property def dex ( self ): return self . _dex @dex . setter def dex ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else: self . set_stat_by_column ( \"dex\" , amount ) self . _dex = amount def add_dex ( self , amount ): \"\"\"Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool \"\"\" new_dex = int ( self . dex ) + amount if new_dex > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else: self . dex = new_dex @property def inte ( self ): return self . _inte @inte . setter def inte ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else: self . set_stat_by_column ( \"int\" , amount ) self . _inte = amount def add_inte ( self , amount ): \"\"\"Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool \"\"\" new_inte = int ( self . inte ) + amount if new_inte > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else: self . inte = new_inte @property def luk ( self ): return self . _luk @luk . setter def luk ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else: self . set_stat_by_column ( \"luk\" , amount ) self . _luk = amount def add_luk ( self , amount ): \"\"\"Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool \"\"\" new_luk = int ( self . luk ) + amount if new_luk > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else: self . luk = new_luk def get_primary_stats ( self ): \"\"\"Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats \"\"\" primary_stats = { \"str\" : self . strength , \"dex\" : self . dex , \"int\" : self . inte , \"luk\" : self . luk } return primary_stats @property def max_hp ( self ): return self . _max_hp @max_hp . setter def max_hp ( self , amount ): self . set_stat_by_column ( \"maxhp\" , amount ) self . _max_hp = amount def add_max_hp ( self , amount ): \"\"\"Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool \"\"\" new_hp = int ( self . max_hp ) + amount self . max_hp = new_hp @property def max_mp ( self ): return self . _max_mp @max_mp . setter def max_mp ( self , amount ): self . set_stat_by_column ( \"maxmp\" , amount ) self . _max_mp = amount def add_max_mp ( self , amount ): \"\"\"Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool \"\"\" new_mp = int ( self . max_mp ) + amount self . max_mp = new_mp @property def ap ( self ): return self . _ap @ap . setter def ap ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else: self . set_stat_by_column ( \"ap\" , amount ) self . _ap = amount def add_ap ( self , amount ): \"\"\"Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool \"\"\" new_ap = int ( self . ap ) + amount if new_ap > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else: self . ap = new_ap @property def bl_slots ( self ): return self . _bl_slots @bl_slots . setter def bl_slots ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"buddyCapacity\" , amount ) self . _bl_slots = amount def add_bl_slots ( self , amount ): # TODO: Add checks new_amount = int ( self . bl_slots ) + amount self . bl_slots = new_amount @property def rebirths ( self ): return self . _rebirths @rebirths . setter def rebirths ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"reborns\" , amount ) self . _rebirths = amount def add_rebirths ( self , amount ): # TODO: Add checks new_amount = int ( self . rebirths ) + amount self . rebirths = new_amount @property def ambition ( self ): return self . _ambition @ambition . setter def ambition ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"ambition\" , amount ) self . _ambition = amount def add_ambition ( self , amount ): # TODO: Add checks new_amount = int ( self . ambition ) + amount self . ambition = new_amount @property def insight ( self ): return self . _insight @insight . setter def insight ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"insight\" , amount ) self . _insight = amount def add_insight ( self , amount ): # TODO: Add checks new_amount = int ( self . insight ) + amount self . insight = new_amount @property def willpower ( self ): return self . _willpower @willpower . setter def willpower ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"willpower\" , amount ) self . _willpower = amount def add_willpower ( self , amount ): # TODO: Add checks new_amount = int ( self . willpower ) + amount self . willpower = new_amount @property def diligence ( self ): return self . _diligence @diligence . setter def diligence ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"diligence\" , amount ) self . _diligence = amount def add_diligence ( self , amount ): # TODO: Add checks new_amount = int ( self . diligence ) + amount self . diligence = new_amount @property def empathy ( self ): return self . _empathy @empathy . setter def empathy ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"empathy\" , amount ) self . _empathy = amount def add_empathy ( self , amount ): # TODO: Add checks new_amount = int ( self . empathy ) + amount self . empathy = new_amount @property def charm ( self ): return self . _charm @charm . setter def charm ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"charm\" , amount ) self . _charm = amount def add_charm ( self , amount ): # TODO: Add checks new_amount = int ( self . charm ) + amount self . charm = new_amount @property def honour ( self ): return self . _honour @honour . setter def honour ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"honour\" , amount ) self . _honour = amount def add_honour ( self , amount ): # TODO: Add checks new_amount = int ( self . honour ) + amount self . honour = new_amount @property def mute ( self ): return self . _mute @mute . setter def mute ( self , status ): # TODO: Add checks self . set_stat_by_column ( \"mute\" , status ) self . _mute = status @property def account ( self ): return self . _account @property def inventory ( self ): return self . _inventory def get_char_img ( self ): \"\"\"Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar \"\"\" equipped_items = [ self . face , self . hair ] equipped_inv = self . inventory . equipped_inv for item in equipped_inv: item_id = equipped_inv [ item ][ \"itemid\" ] equipped_items . append ( item_id ) url = f \"https://maplestory.io/api/GMS/216/Character/200{self.skin}/{str(equipped_items)[1:-1]}/stand1/1\" . replace ( \" \" , \"\" ) return url def set_stat_by_column ( self , column , value ): \"\"\"Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try: database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE name = '{self.name}'\" ) database . commit () print ( f \"Successfully updated {column} value for character: {self.name}.\" ) self . _stats [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e: print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False def get_stat_by_column ( self , column ): \"\"\"Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure \"\"\" try: return self . stats [ column ] except Exception as e: print ( \"[ERROR] Error trying to get stats from given column.\" , e ) return False Instance variables account account_id ambition ap bl_slots character_id charm database_config dex diligence empathy exp face fame gender hair honour insight inte inventory job level luk map max_hp max_mp meso mute name rebirths skin stats strength willpower Methods add_ambition def add_ambition ( self , amount ) View Source def add_ambition ( self , amount ): # TODO : Add checks new_amount = int ( self . ambition ) + amount self . ambition = new_amount add_ap def add_ap ( self , amount ) Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool View Source def add_ap ( self , amount ): \"\"\"Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool \"\"\" new_ap = int ( self . ap ) + amount if new_ap > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else : self . ap = new_ap add_bl_slots def add_bl_slots ( self , amount ) View Source def add_bl_slots ( self , amount ): # TODO : Add checks new_amount = int ( self . bl_slots ) + amount self . bl_slots = new_amount add_charm def add_charm ( self , amount ) View Source def add_charm ( self , amount ): # TODO : Add checks new_amount = int ( self . charm ) + amount self . charm = new_amount add_dex def add_dex ( self , amount ) Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool View Source def add_dex ( self , amount ): \"\"\"Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool \"\"\" new_dex = int ( self . dex ) + amount if new_dex > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else : self . dex = new_dex add_diligence def add_diligence ( self , amount ) View Source def add_diligence ( self , amount ): # TODO : Add checks new_amount = int ( self . diligence ) + amount self . diligence = new_amount add_empathy def add_empathy ( self , amount ) View Source def add_empathy ( self , amount ): # TODO : Add checks new_amount = int ( self . empathy ) + amount self . empathy = new_amount add_exp def add_exp ( self , amount ) Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool View Source def add_exp ( self , amount ): \"\"\"Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool \"\"\" if amount > 2147483647 : raise ValueError ( \"You should not try to increment EXP by more than 2bil!\" ) else : new_exp = int ( self . exp ) + amount self . exp = str ( new_exp ) # EXP is a String ; converting back to String for consistency add_fame def add_fame ( self , amount ) Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count View Source def add_fame ( self , amount ): \"\"\"Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count \"\"\" new_fame = int ( self . fame ) + amount if new_fame > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else : self . fame = new_fame add_honour def add_honour ( self , amount ) View Source def add_honour ( self , amount ): # TODO : Add checks new_amount = int ( self . honour ) + amount self . honour = new_amount add_insight def add_insight ( self , amount ) View Source def add_insight ( self , amount ): # TODO : Add checks new_amount = int ( self . insight ) + amount self . insight = new_amount add_inte def add_inte ( self , amount ) Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool View Source def add_inte ( self , amount ): \"\"\"Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool \"\"\" new_inte = int ( self . inte ) + amount if new_inte > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else : self . inte = new_inte add_level def add_level ( self , amount ) Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count View Source def add_level ( self , amount ): \"\"\"Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count \"\"\" new_level = int ( self . level ) + amount if new_level > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else : self . level = new_level add_luk def add_luk ( self , amount ) Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool View Source def add_luk ( self , amount ): \"\"\"Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool \"\"\" new_luk = int ( self . luk ) + amount if new_luk > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else : self . luk = new_luk add_max_hp def add_max_hp ( self , amount ) Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool View Source def add_max_hp ( self , amount ): \"\"\"Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool \"\"\" new_hp = int ( self . max_hp ) + amount self . max_hp = new_hp add_max_mp def add_max_mp ( self , amount ) Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool View Source def add_max_mp ( self , amount ): \"\"\"Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool \"\"\" new_mp = int ( self . max_mp ) + amount self . max_mp = new_mp add_mesos def add_mesos ( self , amount ) Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count View Source def add_mesos ( self , amount ): \"\"\"Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count \"\"\" new_amount = int ( self . meso ) + amount if new_amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else : self . meso = str ( new_amount ) # money is a String ; converting back to String for consistency add_rebirths def add_rebirths ( self , amount ) View Source def add_rebirths ( self , amount ): # TODO : Add checks new_amount = int ( self . rebirths ) + amount self . rebirths = new_amount add_str def add_str ( self , amount ) Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool View Source def add_str ( self , amount ): \"\"\"Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool \"\"\" new_str = int ( self . strength ) + amount if new_str > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else : self . strength = new_str add_willpower def add_willpower ( self , amount ) View Source def add_willpower ( self , amount ): # TODO : Add checks new_amount = int ( self . willpower ) + amount self . willpower = new_amount get_char_img def get_char_img ( self ) Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar View Source def get_char_img ( self ) : \"\"\"Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar \"\"\" equipped_items = [ self . face , self . hair ] equipped_inv = self . inventory . equipped_inv for item in equipped_inv: item_id = equipped_inv [ item ][ \"itemid\" ] equipped_items . append ( item_id ) url = f \"https://maplestory.io/api/GMS/216/Character/200{self.skin}/{str(equipped_items)[1:-1]}/stand1/1\" . replace ( \" \" , \"\" ) return url get_job_name def get_job_name ( self ) Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID View Source def get_job_name ( self ): \"\"\"Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID \"\"\" return JOBS [ str ( self . job )] get_primary_stats def get_primary_stats ( self ) Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats View Source def get_primary_stats ( self ): \"\"\"Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats \"\"\" primary_stats = { \"str\" : self . strength , \"dex\" : self . dex , \"int\" : self . inte , \"luk\" : self . luk } return primary_stats get_stat_by_column def get_stat_by_column ( self , column ) Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure View Source def get_stat_by_column ( self , column ) : \"\"\"Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure \"\"\" try : return self . stats [ column ] except Exception as e : print ( \"[ERROR] Error trying to get stats from given column.\" , e ) return False init_account def init_account ( self ) Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character:: init (char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method View Source def init_account ( self ): \"\"\"Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character::__init__(char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" account_id = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE id = '{self.character_id}'\" ) . get ( \"accountid\" ) # get_db() returns a Dictionary, so get() is used to fetch only the value # The row will always be 0 because there should be no characters with the same character ID (Primary Key) account_info = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE id = '{account_id}'\" ) # The row will always be 0 because there should be no characters with the same account ID (Primary Key) account = Account ( account_info , self . database_config ) return account init_inventory def init_inventory ( self ) Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character:: init (char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method View Source def init_inventory ( self ): \"\"\"Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character::__init__(char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" inventory = Inventory ( self . character_id , self . database_config ) return inventory init_stats def init_stats ( self ) Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character:: init (char_stats, database_config). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance. View Source def init_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character :: __init__ ( char_stats , database_config ). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance . \"\"\" self . _character_id = self . _stats [' id '] self . _account_id = self . _stats [' accountid '] self . _name = self . _stats [' name '] self . _level = self . _stats [' level '] self . _exp = self . _stats [' exp '] self . _strength = self . _stats [' str '] self . _dex = self . _stats [' dex '] self . _luk = self . _stats [' luk '] self . _inte = self . _stats [' int '] self . _max_hp = self . _stats [' maxhp '] self . _max_mp = self . _stats [' maxmp '] self . _meso = self . _stats [' meso '] self . _job = self . _stats [' job '] self . _skin = self . _stats [' skincolor '] self . _gender = self . _stats [' gender '] self . _fame = self . _stats [' fame '] self . _hair = self . _stats [ 'ha ir '] self . _face = self . _stats [' face '] self . _ap = self . _stats [' ap '] self . _map = self . _stats [' map '] self . _bl_slots = self . _stats [' buddyCapacity '] self . _rebirths = self . _stats [' reborns '] self . _ambition = self . _stats [' ambition '] self . _insight = self . _stats [' insight '] self . _willpower = self . _stats [' willpower '] self . _diligence = self . _stats [' diligence '] self . _empathy = self . _stats [' empathy '] self . _charm = self . _stats [' charm '] self . _honour = self . _stats [' innerExp '] # Best guess - might be wrong ! self . _mute = self . _stats [' chatban '] set_stat_by_column def set_stat_by_column ( self , column , value ) Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name View Source def set_stat_by_column ( self , column , value ) : \"\"\"Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE name = '{self.name}'\" ) database . commit () print ( f \"Successfully updated {column} value for character: {self.name}.\" ) self . _stats [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False","title":"Character"},{"location":"reference/lazuli/character/#module-lazulicharacter","text":"This module holds the Character class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the Character class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql . connector as con from lazuli import JOBS from lazuli . inventory import Inventory from lazuli . account import Account import lazuli . utility as utils class Character : \"\"\"Character object; models AzureMS characters. Using instance method Lazuli::get_char_by_name(name) will create a Character object instance with attributes identical to the character with IGN \" name \" in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: character_id: Integer, representing Primary Key for Character; int(11) account_id: Integer, representing Primary Key for Account (FK); int(11) name: String, representing Character IGN; varchar(13) level: Integer, representing Character level exp: Integer, representing Character EXP; bigint(20) strength: Integer, representing Character STR stat pool dex: Integer, representing Character DEX stat pool luk: Integer, representing Character LUK stat pool inte: Integer, representing Character INT stat pool max_hp: Integer, representing Character Max HP stat pool max_mp: Integer, representing Character Max MP stat pool meso: Integer, representing character wealth (aka Meso count) job: Integer, representing Job ID of the character skin: Integer, representing Skin ID of the character gender: Integer, representing Gender ID of the character fame: Integer, representing Character fame count hair: Integer, representing Hair ID of the character face: Integer, representing Face ID of the character ap: Integer, representing Character free Ability Points (AP) pool map: Integer, representing Map ID of the map that the character is currently in bl_slots: Integer, representing Character Buddy List slots rebirths: Integer, representing Character rebirth count ambition: Integer, representing Character Ambition pool insight: Integer, representing Character Insight pool willpower: Integer, representing Character Willpower pool diligence: Integer, representing Character Diligence pool empathy: Integer, representing Character Empathy pool charm: Integer, representing Character Charm pool honour: Integer, representing Character Honour pool mute: String, representing whether a character is chat-banned \"\"\" def __ init__ ( self , char_stats , database_config ) : \"\"\"Emulates how character object is handled server-sided Not all character attributes are inherited, as the database table design in AzureMS is quite verbose Args: char_stats: dictionary of character stats, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _ stats = char_stats self . _ database_config = database_config self . _ character_id = 0 self . _ account_id = 0 self . _ name = \"\" # varchar 13 self . _ level = 0 self . _ exp = 0 self . _ strength = 0 self . _ dex = 0 self . _ luk = 0 self . _ inte = 0 self . _ max_hp = 0 self . _ max_mp = 0 self . _ meso = 0 self . _ job = 0 self . _ skin = 0 self . _ gender = 0 self . _ fame = 0 self . _ hair = 0 self . _ face = 0 self . _ ap = 0 self . _ map = 0 self . _ bl_slots = 0 self . _ rebirths = 0 self . _ ambition = 0 self . _ insight = 0 self . _ willpower = 0 self . _ diligence = 0 self . _ empathy = 0 self . _ charm = 0 self . _ honour = 0 self . _ mute = \"\" # Takes lower case true / false but is a varchar ( 45 ) and not a Bool self . init_stats () # Assign instance variables # Create Inventory object instance via class constructor , using details from Character object instance self . _ inventory = self . init_inventory () # Create Account object instance via class constructor , using details from Character object instance self . _ account = self . init_account () # fill with attributes from init def init_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character::__init__(char_stats, database_config). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance. \"\"\" self . _ character_id = self . _ stats [ 'id' ] self . _ account_id = self . _ stats [ 'accountid' ] self . _ name = self . _ stats [ 'name' ] self . _ level = self . _ stats [ 'level' ] self . _ exp = self . _ stats [ 'exp' ] self . _ strength = self . _ stats [ 'str' ] self . _ dex = self . _ stats [ 'dex' ] self . _ luk = self . _ stats [ 'luk' ] self . _ inte = self . _ stats [ 'int' ] self . _ max_hp = self . _ stats [ 'maxhp' ] self . _ max_mp = self . _ stats [ 'maxmp' ] self . _ meso = self . _ stats [ 'meso' ] self . _ job = self . _ stats [ 'job' ] self . _ skin = self . _ stats [ 'skincolor' ] self . _ gender = self . _ stats [ 'gender' ] self . _ fame = self . _ stats [ 'fame' ] self . _ hair = self . _ stats [ 'hair' ] self . _ face = self . _ stats [ 'face' ] self . _ ap = self . _ stats [ 'ap' ] self . _ map = self . _ stats [ 'map' ] self . _ bl_slots = self . _ stats [ 'buddyCapacity' ] self . _ rebirths = self . _ stats [ 'reborns' ] self . _ ambition = self . _ stats [ 'ambition' ] self . _ insight = self . _ stats [ 'insight' ] self . _ willpower = self . _ stats [ 'willpower' ] self . _ diligence = self . _ stats [ 'diligence' ] self . _ empathy = self . _ stats [ 'empathy' ] self . _ charm = self . _ stats [ 'charm' ] self . _ honour = self . _ stats [ 'innerExp' ] # Best guess - might be wrong ! self . _ mute = self . _ stats [ 'chatban' ] def init_account ( self ) : \"\"\"Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character::__init__(char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" account_id = utils . get_db_first_hit ( self . _ database_config , f \"SELECT * FROM characters WHERE id = '{self.character_id}'\" ). get ( \"accountid\" ) # get_db () returns a Dictionary , so get () is used to fetch only the value # The row will always be 0 because there should be no characters with the same character ID ( Primary Key ) account_info = utils . get_db_first_hit ( self . _ database_config , f \"SELECT * FROM accounts WHERE id = '{account_id}'\" ) # The row will always be 0 because there should be no characters with the same account ID ( Primary Key ) account = Account ( account_info , self . database_config ) return account def init_inventory ( self ) : \"\"\"Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character::__init__(char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" inventory = Inventory ( self . character_id , self . database_config ) return inventory @property def database_config ( self ) : return self . _ database_config @property def stats ( self ) : return self . _ stats @property def character_id ( self ) : return self . _ character_id # Only getter , no setter ; Primary Key must not be set manually ! @property def account_id ( self ) : return self . _ account_id # Only getter , no setter ; Primary Key must not be set manually ! @property def level ( self ) : return self . _ level @level . setter def level ( self , x ) : if x > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else : self . set_stat_by_column ( \"level\" , x ) self . _ level = x def add_level ( self , amount ) : \"\"\"Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count \"\"\" new_level = int ( self . level ) + amount if new_level > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else : self . level = new_level @property def job ( self ) : return self . _ job @job . setter def job ( self , job_id ) : if str ( job_id ) not in JOBS : raise ValueError ( \"Invalid Job ID!\" ) else : self . set_stat_by_column ( \"job\" , job_id ) self . _ job = job_id def get_job_name ( self ) : \"\"\"Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID \"\"\" return JOBS [ str ( self . job )] @property def name ( self ) : return self . _ name @name . setter def name ( self , new_name ) : \"\"\"Set a new name for the character Args: new_name: string, representing the new character name that will be set in the database \"\"\" if len ( new_name ) > 13 : raise ValueError ( \"Character names can only be 13 characters long!\" ) else : self . set_stat_by_column ( \"name\" , new_name ) self . _ name = new_name @property def meso ( self ) : return self . _ meso @meso . setter def meso ( self , amount ) : if amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else : self . set_stat_by_column ( \"meso\" , amount ) self . _ meso = amount def add_mesos ( self , amount ) : \"\"\"Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count \"\"\" new_amount = int ( self . meso ) + amount if new_amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else : self . meso = str ( new_amount ) # money is a String ; converting back to String for consistency @property def fame ( self ) : return self . _ fame @fame . setter def fame ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else : self . set_stat_by_column ( \"fame\" , amount ) self . _ fame = amount def add_fame ( self , amount ) : \"\"\"Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count \"\"\" new_fame = int ( self . fame ) + amount if new_fame > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else : self . fame = new_fame @property def map ( self ) : return self . _ map @map . setter def map ( self , map_id ) : if map_id < 100000000 or map_id > 999999999 : # Best guess - might be wrong ! raise ValueError ( \"Wrong map ID!\" ) else : self . set_stat_by_column ( \"map\" , map_id ) self . _ map = map_id @property def face ( self ) : return self . _ face @face . setter def face ( self , face_id ) : self . set_stat_by_column ( \"face\" , face_id ) # TODO : Add check self . _ face = face_id @property def hair ( self ) : return self . _ hair @hair . setter def hair ( self , hair_id ) : self . set_stat_by_column ( \"hair\" , hair_id ) # TODO : Add check self . _ hair = hair_id @property def skin ( self ) : return self . _ skin @skin . setter def skin ( self , skin_id ) : self . set_stat_by_column ( \"skin\" , skin_id ) # TODO : Add check self . _ skin = skin_id @property def gender ( self ) : return self . _ gender @gender . setter def gender ( self , gender_id ) : self . set_stat_by_column ( \"gender\" , gender_id ) # TODO : Add check self . _ gender = gender_id @property def exp ( self ) : return self . _ exp @exp . setter def exp ( self , exp_amount ) : if exp_amount > 2147483647 : raise ValueError ( \"You should not try to set EXP above 2bil!\" ) else : self . set_stat_by_column ( \"exp\" , exp_amount ) self . _ exp = exp_amount def add_exp ( self , amount ) : \"\"\"Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool \"\"\" if amount > 2147483647 : raise ValueError ( \"You should not try to increment EXP by more than 2bil!\" ) else : new_exp = int ( self . exp ) + amount self . exp = str ( new_exp ) # EXP is a String ; converting back to String for consistency @property def strength ( self ) : return self . _ strength @strength . setter def strength ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else : self . set_stat_by_column ( \"str\" , amount ) self . _ strength = amount def add_str ( self , amount ) : \"\"\"Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool \"\"\" new_str = int ( self . strength ) + amount if new_str > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else : self . strength = new_str @property def dex ( self ) : return self . _ dex @dex . setter def dex ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else : self . set_stat_by_column ( \"dex\" , amount ) self . _ dex = amount def add_dex ( self , amount ) : \"\"\"Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool \"\"\" new_dex = int ( self . dex ) + amount if new_dex > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else : self . dex = new_dex @property def inte ( self ) : return self . _ inte @inte . setter def inte ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else : self . set_stat_by_column ( \"int\" , amount ) self . _ inte = amount def add_inte ( self , amount ) : \"\"\"Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool \"\"\" new_inte = int ( self . inte ) + amount if new_inte > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else : self . inte = new_inte @property def luk ( self ) : return self . _ luk @luk . setter def luk ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else : self . set_stat_by_column ( \"luk\" , amount ) self . _ luk = amount def add_luk ( self , amount ) : \"\"\"Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool \"\"\" new_luk = int ( self . luk ) + amount if new_luk > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else : self . luk = new_luk def get_primary_stats ( self ) : \"\"\"Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats \"\"\" primary_stats = { \"str\" : self . strength , \"dex\" : self . dex , \"int\" : self . inte , \"luk\" : self . luk } return primary_stats @property def max_hp ( self ) : return self . _ max_hp @max_hp . setter def max_hp ( self , amount ) : self . set_stat_by_column ( \"maxhp\" , amount ) self . _ max_hp = amount def add_max_hp ( self , amount ) : \"\"\"Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool \"\"\" new_hp = int ( self . max_hp ) + amount self . max_hp = new_hp @property def max_mp ( self ) : return self . _ max_mp @max_mp . setter def max_mp ( self , amount ) : self . set_stat_by_column ( \"maxmp\" , amount ) self . _ max_mp = amount def add_max_mp ( self , amount ) : \"\"\"Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool \"\"\" new_mp = int ( self . max_mp ) + amount self . max_mp = new_mp @property def ap ( self ) : return self . _ ap @ap . setter def ap ( self , amount ) : if amount > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else : self . set_stat_by_column ( \"ap\" , amount ) self . _ ap = amount def add_ap ( self , amount ) : \"\"\"Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool \"\"\" new_ap = int ( self . ap ) + amount if new_ap > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else : self . ap = new_ap @property def bl_slots ( self ) : return self . _ bl_slots @bl_slots . setter def bl_slots ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"buddyCapacity\" , amount ) self . _ bl_slots = amount def add_bl_slots ( self , amount ) : # TODO : Add checks new_amount = int ( self . bl_slots ) + amount self . bl_slots = new_amount @property def rebirths ( self ) : return self . _ rebirths @rebirths . setter def rebirths ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"reborns\" , amount ) self . _ rebirths = amount def add_rebirths ( self , amount ) : # TODO : Add checks new_amount = int ( self . rebirths ) + amount self . rebirths = new_amount @property def ambition ( self ) : return self . _ ambition @ambition . setter def ambition ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"ambition\" , amount ) self . _ ambition = amount def add_ambition ( self , amount ) : # TODO : Add checks new_amount = int ( self . ambition ) + amount self . ambition = new_amount @property def insight ( self ) : return self . _ insight @insight . setter def insight ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"insight\" , amount ) self . _ insight = amount def add_insight ( self , amount ) : # TODO : Add checks new_amount = int ( self . insight ) + amount self . insight = new_amount @property def willpower ( self ) : return self . _ willpower @willpower . setter def willpower ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"willpower\" , amount ) self . _ willpower = amount def add_willpower ( self , amount ) : # TODO : Add checks new_amount = int ( self . willpower ) + amount self . willpower = new_amount @property def diligence ( self ) : return self . _ diligence @diligence . setter def diligence ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"diligence\" , amount ) self . _ diligence = amount def add_diligence ( self , amount ) : # TODO : Add checks new_amount = int ( self . diligence ) + amount self . diligence = new_amount @property def empathy ( self ) : return self . _ empathy @empathy . setter def empathy ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"empathy\" , amount ) self . _ empathy = amount def add_empathy ( self , amount ) : # TODO : Add checks new_amount = int ( self . empathy ) + amount self . empathy = new_amount @property def charm ( self ) : return self . _ charm @charm . setter def charm ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"charm\" , amount ) self . _ charm = amount def add_charm ( self , amount ) : # TODO : Add checks new_amount = int ( self . charm ) + amount self . charm = new_amount @property def honour ( self ) : return self . _ honour @honour . setter def honour ( self , amount ) : # TODO : Add checks self . set_stat_by_column ( \"honour\" , amount ) self . _ honour = amount def add_honour ( self , amount ) : # TODO : Add checks new_amount = int ( self . honour ) + amount self . honour = new_amount @property def mute ( self ) : return self . _ mute @mute . setter def mute ( self , status ) : # TODO : Add checks self . set_stat_by_column ( \"mute\" , status ) self . _ mute = status @property def account ( self ) : return self . _ account @property def inventory ( self ) : return self . _ inventory def get_char_img ( self ) : \"\"\"Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar \"\"\" equipped_items = [ self . face , self . hair ] equipped_inv = self . inventory . equipped_inv for item in equipped_inv: item_id = equipped_inv [ item ][ \"itemid\" ] equipped_items . append ( item_id ) url = f \"https://maplestory.io/api/GMS/216/Character/200{self.skin}/{str(equipped_items)[1:-1]}/stand1/1\" . replace ( \" \" , \"\" ) return url def set_stat_by_column ( self , column , value ) : \"\"\"Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _ database_config [ \"host\" ] user = self . _ database_config [ \"user\" ] password = self . _ database_config [ \"password\" ] schema = self . _ database_config [ \"schema\" ] port = self . _ database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE name = '{self.name}'\" ) database . commit () print ( f \"Successfully updated {column} value for character: {self.name}.\" ) self . _ stats [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False def get_stat_by_column ( self , column ) : \"\"\"Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure \"\"\" try : return self . stats [ column ] except Exception as e : print ( \"[ERROR] Error trying to get stats from given column.\" , e ) return False","title":"Module lazuli.character"},{"location":"reference/lazuli/character/#variables","text":"JOBS","title":"Variables"},{"location":"reference/lazuli/character/#classes","text":"","title":"Classes"},{"location":"reference/lazuli/character/#character","text":"class Character ( char_stats , database_config ) Character object; models AzureMS characters. Using instance method Lazuli::get_char_by_name(name) will create a Character object instance with attributes identical to the character with IGN \"name\" in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: character_id: Integer, representing Primary Key for Character; int(11) account_id: Integer, representing Primary Key for Account (FK); int(11) name: String, representing Character IGN; varchar(13) level: Integer, representing Character level exp: Integer, representing Character EXP; bigint(20) strength: Integer, representing Character STR stat pool dex: Integer, representing Character DEX stat pool luk: Integer, representing Character LUK stat pool inte: Integer, representing Character INT stat pool max_hp: Integer, representing Character Max HP stat pool max_mp: Integer, representing Character Max MP stat pool meso: Integer, representing character wealth (aka Meso count) job: Integer, representing Job ID of the character skin: Integer, representing Skin ID of the character gender: Integer, representing Gender ID of the character fame: Integer, representing Character fame count hair: Integer, representing Hair ID of the character face: Integer, representing Face ID of the character ap: Integer, representing Character free Ability Points (AP) pool map: Integer, representing Map ID of the map that the character is currently in bl_slots: Integer, representing Character Buddy List slots rebirths: Integer, representing Character rebirth count ambition: Integer, representing Character Ambition pool insight: Integer, representing Character Insight pool willpower: Integer, representing Character Willpower pool diligence: Integer, representing Character Diligence pool empathy: Integer, representing Character Empathy pool charm: Integer, representing Character Charm pool honour: Integer, representing Character Honour pool mute: String, representing whether a character is chat-banned View Source class Character: \"\"\"Character object; models AzureMS characters. Using instance method Lazuli::get_char_by_name(name) will create a Character object instance with attributes identical to the character with IGN \" name \" in the connected AzureMS-based database. This class contains the appropriate getter and setter methods for said attributes. Attributes: character_id: Integer, representing Primary Key for Character; int(11) account_id: Integer, representing Primary Key for Account (FK); int(11) name: String, representing Character IGN; varchar(13) level: Integer, representing Character level exp: Integer, representing Character EXP; bigint(20) strength: Integer, representing Character STR stat pool dex: Integer, representing Character DEX stat pool luk: Integer, representing Character LUK stat pool inte: Integer, representing Character INT stat pool max_hp: Integer, representing Character Max HP stat pool max_mp: Integer, representing Character Max MP stat pool meso: Integer, representing character wealth (aka Meso count) job: Integer, representing Job ID of the character skin: Integer, representing Skin ID of the character gender: Integer, representing Gender ID of the character fame: Integer, representing Character fame count hair: Integer, representing Hair ID of the character face: Integer, representing Face ID of the character ap: Integer, representing Character free Ability Points (AP) pool map: Integer, representing Map ID of the map that the character is currently in bl_slots: Integer, representing Character Buddy List slots rebirths: Integer, representing Character rebirth count ambition: Integer, representing Character Ambition pool insight: Integer, representing Character Insight pool willpower: Integer, representing Character Willpower pool diligence: Integer, representing Character Diligence pool empathy: Integer, representing Character Empathy pool charm: Integer, representing Character Charm pool honour: Integer, representing Character Honour pool mute: String, representing whether a character is chat-banned \"\"\" def __init__ ( self , char_stats , database_config ): \"\"\"Emulates how character object is handled server-sided Not all character attributes are inherited, as the database table design in AzureMS is quite verbose Args: char_stats: dictionary of character stats, formatted in AzureMS style database_config: dictionary of protected attributes from a Lazuli object \"\"\" self . _stats = char_stats self . _database_config = database_config self . _character_id = 0 self . _account_id = 0 self . _name = \"\" # varchar 13 self . _level = 0 self . _exp = 0 self . _strength = 0 self . _dex = 0 self . _luk = 0 self . _inte = 0 self . _max_hp = 0 self . _max_mp = 0 self . _meso = 0 self . _job = 0 self . _skin = 0 self . _gender = 0 self . _fame = 0 self . _hair = 0 self . _face = 0 self . _ap = 0 self . _map = 0 self . _bl_slots = 0 self . _rebirths = 0 self . _ambition = 0 self . _insight = 0 self . _willpower = 0 self . _diligence = 0 self . _empathy = 0 self . _charm = 0 self . _honour = 0 self . _mute = \"\" # Takes lower case true/false but is a varchar (45) and not a Bool self . init_stats () # Assign instance variables # Create Inventory object instance via class constructor, using details from Character object instance self . _inventory = self . init_inventory () # Create Account object instance via class constructor, using details from Character object instance self . _account = self . init_account () # fill with attributes from init def init_stats ( self ): \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character::__init__(char_stats, database_config). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance. \"\"\" self . _character_id = self . _stats [ 'id' ] self . _account_id = self . _stats [ 'accountid' ] self . _name = self . _stats [ 'name' ] self . _level = self . _stats [ 'level' ] self . _exp = self . _stats [ 'exp' ] self . _strength = self . _stats [ 'str' ] self . _dex = self . _stats [ 'dex' ] self . _luk = self . _stats [ 'luk' ] self . _inte = self . _stats [ 'int' ] self . _max_hp = self . _stats [ 'maxhp' ] self . _max_mp = self . _stats [ 'maxmp' ] self . _meso = self . _stats [ 'meso' ] self . _job = self . _stats [ 'job' ] self . _skin = self . _stats [ 'skincolor' ] self . _gender = self . _stats [ 'gender' ] self . _fame = self . _stats [ 'fame' ] self . _hair = self . _stats [ 'hair' ] self . _face = self . _stats [ 'face' ] self . _ap = self . _stats [ 'ap' ] self . _map = self . _stats [ 'map' ] self . _bl_slots = self . _stats [ 'buddyCapacity' ] self . _rebirths = self . _stats [ 'reborns' ] self . _ambition = self . _stats [ 'ambition' ] self . _insight = self . _stats [ 'insight' ] self . _willpower = self . _stats [ 'willpower' ] self . _diligence = self . _stats [ 'diligence' ] self . _empathy = self . _stats [ 'empathy' ] self . _charm = self . _stats [ 'charm' ] self . _honour = self . _stats [ 'innerExp' ] # Best guess - might be wrong! self . _mute = self . _stats [ 'chatban' ] def init_account ( self ): \"\"\"Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character::__init__(char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" account_id = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE id = '{self.character_id}'\" ). get ( \"accountid\" ) # get_db() returns a Dictionary, so get() is used to fetch only the value # The row will always be 0 because there should be no characters with the same character ID (Primary Key) account_info = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE id = '{account_id}'\" ) # The row will always be 0 because there should be no characters with the same account ID (Primary Key) account = Account ( account_info , self . database_config ) return account def init_inventory ( self ): \"\"\"Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character::__init__(char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" inventory = Inventory ( self . character_id , self . database_config ) return inventory @property def database_config ( self ): return self . _database_config @property def stats ( self ): return self . _stats @property def character_id ( self ): return self . _character_id # Only getter, no setter; Primary Key must not be set manually! @property def account_id ( self ): return self . _account_id # Only getter, no setter; Primary Key must not be set manually! @property def level ( self ): return self . _level @level . setter def level ( self , x ): if x > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else: self . set_stat_by_column ( \"level\" , x ) self . _level = x def add_level ( self , amount ): \"\"\"Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count \"\"\" new_level = int ( self . level ) + amount if new_level > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else: self . level = new_level @property def job ( self ): return self . _job @job . setter def job ( self , job_id ): if str ( job_id ) not in JOBS: raise ValueError ( \"Invalid Job ID!\" ) else: self . set_stat_by_column ( \"job\" , job_id ) self . _job = job_id def get_job_name ( self ): \"\"\"Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID \"\"\" return JOBS [ str ( self . job )] @property def name ( self ): return self . _name @name . setter def name ( self , new_name ): \"\"\"Set a new name for the character Args: new_name: string, representing the new character name that will be set in the database \"\"\" if len ( new_name ) > 13 : raise ValueError ( \"Character names can only be 13 characters long!\" ) else: self . set_stat_by_column ( \"name\" , new_name ) self . _name = new_name @property def meso ( self ): return self . _meso @meso . setter def meso ( self , amount ): if amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else: self . set_stat_by_column ( \"meso\" , amount ) self . _meso = amount def add_mesos ( self , amount ): \"\"\"Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count \"\"\" new_amount = int ( self . meso ) + amount if new_amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else: self . meso = str ( new_amount ) # money is a String; converting back to String for consistency @property def fame ( self ): return self . _fame @fame . setter def fame ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else: self . set_stat_by_column ( \"fame\" , amount ) self . _fame = amount def add_fame ( self , amount ): \"\"\"Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count \"\"\" new_fame = int ( self . fame ) + amount if new_fame > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else: self . fame = new_fame @property def map ( self ): return self . _map @map . setter def map ( self , map_id ): if map_id < 100000000 or map_id > 999999999 : # Best guess - might be wrong! raise ValueError ( \"Wrong map ID!\" ) else: self . set_stat_by_column ( \"map\" , map_id ) self . _map = map_id @property def face ( self ): return self . _face @face . setter def face ( self , face_id ): self . set_stat_by_column ( \"face\" , face_id ) # TODO: Add check self . _face = face_id @property def hair ( self ): return self . _hair @hair . setter def hair ( self , hair_id ): self . set_stat_by_column ( \"hair\" , hair_id ) # TODO: Add check self . _hair = hair_id @property def skin ( self ): return self . _skin @skin . setter def skin ( self , skin_id ): self . set_stat_by_column ( \"skin\" , skin_id ) # TODO: Add check self . _skin = skin_id @property def gender ( self ): return self . _gender @gender . setter def gender ( self , gender_id ): self . set_stat_by_column ( \"gender\" , gender_id ) # TODO: Add check self . _gender = gender_id @property def exp ( self ): return self . _exp @exp . setter def exp ( self , exp_amount ): if exp_amount > 2147483647 : raise ValueError ( \"You should not try to set EXP above 2bil!\" ) else: self . set_stat_by_column ( \"exp\" , exp_amount ) self . _exp = exp_amount def add_exp ( self , amount ): \"\"\"Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool \"\"\" if amount > 2147483647 : raise ValueError ( \"You should not try to increment EXP by more than 2bil!\" ) else: new_exp = int ( self . exp ) + amount self . exp = str ( new_exp ) # EXP is a String; converting back to String for consistency @property def strength ( self ): return self . _strength @strength . setter def strength ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else: self . set_stat_by_column ( \"str\" , amount ) self . _strength = amount def add_str ( self , amount ): \"\"\"Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool \"\"\" new_str = int ( self . strength ) + amount if new_str > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else: self . strength = new_str @property def dex ( self ): return self . _dex @dex . setter def dex ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else: self . set_stat_by_column ( \"dex\" , amount ) self . _dex = amount def add_dex ( self , amount ): \"\"\"Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool \"\"\" new_dex = int ( self . dex ) + amount if new_dex > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else: self . dex = new_dex @property def inte ( self ): return self . _inte @inte . setter def inte ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else: self . set_stat_by_column ( \"int\" , amount ) self . _inte = amount def add_inte ( self , amount ): \"\"\"Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool \"\"\" new_inte = int ( self . inte ) + amount if new_inte > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else: self . inte = new_inte @property def luk ( self ): return self . _luk @luk . setter def luk ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else: self . set_stat_by_column ( \"luk\" , amount ) self . _luk = amount def add_luk ( self , amount ): \"\"\"Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool \"\"\" new_luk = int ( self . luk ) + amount if new_luk > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else: self . luk = new_luk def get_primary_stats ( self ): \"\"\"Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats \"\"\" primary_stats = { \"str\" : self . strength , \"dex\" : self . dex , \"int\" : self . inte , \"luk\" : self . luk } return primary_stats @property def max_hp ( self ): return self . _max_hp @max_hp . setter def max_hp ( self , amount ): self . set_stat_by_column ( \"maxhp\" , amount ) self . _max_hp = amount def add_max_hp ( self , amount ): \"\"\"Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool \"\"\" new_hp = int ( self . max_hp ) + amount self . max_hp = new_hp @property def max_mp ( self ): return self . _max_mp @max_mp . setter def max_mp ( self , amount ): self . set_stat_by_column ( \"maxmp\" , amount ) self . _max_mp = amount def add_max_mp ( self , amount ): \"\"\"Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool \"\"\" new_mp = int ( self . max_mp ) + amount self . max_mp = new_mp @property def ap ( self ): return self . _ap @ap . setter def ap ( self , amount ): if amount > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else: self . set_stat_by_column ( \"ap\" , amount ) self . _ap = amount def add_ap ( self , amount ): \"\"\"Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool \"\"\" new_ap = int ( self . ap ) + amount if new_ap > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else: self . ap = new_ap @property def bl_slots ( self ): return self . _bl_slots @bl_slots . setter def bl_slots ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"buddyCapacity\" , amount ) self . _bl_slots = amount def add_bl_slots ( self , amount ): # TODO: Add checks new_amount = int ( self . bl_slots ) + amount self . bl_slots = new_amount @property def rebirths ( self ): return self . _rebirths @rebirths . setter def rebirths ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"reborns\" , amount ) self . _rebirths = amount def add_rebirths ( self , amount ): # TODO: Add checks new_amount = int ( self . rebirths ) + amount self . rebirths = new_amount @property def ambition ( self ): return self . _ambition @ambition . setter def ambition ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"ambition\" , amount ) self . _ambition = amount def add_ambition ( self , amount ): # TODO: Add checks new_amount = int ( self . ambition ) + amount self . ambition = new_amount @property def insight ( self ): return self . _insight @insight . setter def insight ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"insight\" , amount ) self . _insight = amount def add_insight ( self , amount ): # TODO: Add checks new_amount = int ( self . insight ) + amount self . insight = new_amount @property def willpower ( self ): return self . _willpower @willpower . setter def willpower ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"willpower\" , amount ) self . _willpower = amount def add_willpower ( self , amount ): # TODO: Add checks new_amount = int ( self . willpower ) + amount self . willpower = new_amount @property def diligence ( self ): return self . _diligence @diligence . setter def diligence ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"diligence\" , amount ) self . _diligence = amount def add_diligence ( self , amount ): # TODO: Add checks new_amount = int ( self . diligence ) + amount self . diligence = new_amount @property def empathy ( self ): return self . _empathy @empathy . setter def empathy ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"empathy\" , amount ) self . _empathy = amount def add_empathy ( self , amount ): # TODO: Add checks new_amount = int ( self . empathy ) + amount self . empathy = new_amount @property def charm ( self ): return self . _charm @charm . setter def charm ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"charm\" , amount ) self . _charm = amount def add_charm ( self , amount ): # TODO: Add checks new_amount = int ( self . charm ) + amount self . charm = new_amount @property def honour ( self ): return self . _honour @honour . setter def honour ( self , amount ): # TODO: Add checks self . set_stat_by_column ( \"honour\" , amount ) self . _honour = amount def add_honour ( self , amount ): # TODO: Add checks new_amount = int ( self . honour ) + amount self . honour = new_amount @property def mute ( self ): return self . _mute @mute . setter def mute ( self , status ): # TODO: Add checks self . set_stat_by_column ( \"mute\" , status ) self . _mute = status @property def account ( self ): return self . _account @property def inventory ( self ): return self . _inventory def get_char_img ( self ): \"\"\"Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar \"\"\" equipped_items = [ self . face , self . hair ] equipped_inv = self . inventory . equipped_inv for item in equipped_inv: item_id = equipped_inv [ item ][ \"itemid\" ] equipped_items . append ( item_id ) url = f \"https://maplestory.io/api/GMS/216/Character/200{self.skin}/{str(equipped_items)[1:-1]}/stand1/1\" . replace ( \" \" , \"\" ) return url def set_stat_by_column ( self , column , value ): \"\"\"Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try: database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE name = '{self.name}'\" ) database . commit () print ( f \"Successfully updated {column} value for character: {self.name}.\" ) self . _stats [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e: print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False def get_stat_by_column ( self , column ): \"\"\"Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure \"\"\" try: return self . stats [ column ] except Exception as e: print ( \"[ERROR] Error trying to get stats from given column.\" , e ) return False","title":"Character"},{"location":"reference/lazuli/character/#instance-variables","text":"account account_id ambition ap bl_slots character_id charm database_config dex diligence empathy exp face fame gender hair honour insight inte inventory job level luk map max_hp max_mp meso mute name rebirths skin stats strength willpower","title":"Instance variables"},{"location":"reference/lazuli/character/#methods","text":"","title":"Methods"},{"location":"reference/lazuli/character/#add_ambition","text":"def add_ambition ( self , amount ) View Source def add_ambition ( self , amount ): # TODO : Add checks new_amount = int ( self . ambition ) + amount self . ambition = new_amount","title":"add_ambition"},{"location":"reference/lazuli/character/#add_ap","text":"def add_ap ( self , amount ) Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool View Source def add_ap ( self , amount ): \"\"\"Add the specified amount to the current existing free AP pool Args: amount: Int, representing the amount of free AP to be added to the current pool \"\"\" new_ap = int ( self . ap ) + amount if new_ap > 32767 : raise ValueError ( \"You should not try to set AP above 30k!\" ) else : self . ap = new_ap","title":"add_ap"},{"location":"reference/lazuli/character/#add_bl_slots","text":"def add_bl_slots ( self , amount ) View Source def add_bl_slots ( self , amount ): # TODO : Add checks new_amount = int ( self . bl_slots ) + amount self . bl_slots = new_amount","title":"add_bl_slots"},{"location":"reference/lazuli/character/#add_charm","text":"def add_charm ( self , amount ) View Source def add_charm ( self , amount ): # TODO : Add checks new_amount = int ( self . charm ) + amount self . charm = new_amount","title":"add_charm"},{"location":"reference/lazuli/character/#add_dex","text":"def add_dex ( self , amount ) Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool View Source def add_dex ( self , amount ): \"\"\"Add the specified amount to the current existing DEX pool Args: amount: Int, representing the amount of DEX to be added to the current pool \"\"\" new_dex = int ( self . dex ) + amount if new_dex > 32767 : raise ValueError ( \"You should not try to set DEX above 30k!\" ) else : self . dex = new_dex","title":"add_dex"},{"location":"reference/lazuli/character/#add_diligence","text":"def add_diligence ( self , amount ) View Source def add_diligence ( self , amount ): # TODO : Add checks new_amount = int ( self . diligence ) + amount self . diligence = new_amount","title":"add_diligence"},{"location":"reference/lazuli/character/#add_empathy","text":"def add_empathy ( self , amount ) View Source def add_empathy ( self , amount ): # TODO : Add checks new_amount = int ( self . empathy ) + amount self . empathy = new_amount","title":"add_empathy"},{"location":"reference/lazuli/character/#add_exp","text":"def add_exp ( self , amount ) Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool View Source def add_exp ( self , amount ): \"\"\"Add the specified amount to the current existing EXP pool Args: amount: Int, representing the amount of EXP to be added to the current pool \"\"\" if amount > 2147483647 : raise ValueError ( \"You should not try to increment EXP by more than 2bil!\" ) else : new_exp = int ( self . exp ) + amount self . exp = str ( new_exp ) # EXP is a String ; converting back to String for consistency","title":"add_exp"},{"location":"reference/lazuli/character/#add_fame","text":"def add_fame ( self , amount ) Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count View Source def add_fame ( self , amount ): \"\"\"Adds the specified amount to the current fame count Args: amount: Int, representing the number of fames to be added to the current count \"\"\" new_fame = int ( self . fame ) + amount if new_fame > 32767 : raise ValueError ( \"You should not try to set fame to more than 30k!\" ) else : self . fame = new_fame","title":"add_fame"},{"location":"reference/lazuli/character/#add_honour","text":"def add_honour ( self , amount ) View Source def add_honour ( self , amount ): # TODO : Add checks new_amount = int ( self . honour ) + amount self . honour = new_amount","title":"add_honour"},{"location":"reference/lazuli/character/#add_insight","text":"def add_insight ( self , amount ) View Source def add_insight ( self , amount ): # TODO : Add checks new_amount = int ( self . insight ) + amount self . insight = new_amount","title":"add_insight"},{"location":"reference/lazuli/character/#add_inte","text":"def add_inte ( self , amount ) Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool View Source def add_inte ( self , amount ): \"\"\"Add the specified amount to the current existing INT pool Args: amount: Int, representing the amount of INT to be added to the current pool \"\"\" new_inte = int ( self . inte ) + amount if new_inte > 32767 : raise ValueError ( \"You should not try to set INT above 30k!\" ) else : self . inte = new_inte","title":"add_inte"},{"location":"reference/lazuli/character/#add_level","text":"def add_level ( self , amount ) Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count View Source def add_level ( self , amount ): \"\"\"Adds the specified amount to the current level count Args: amount: Int, representing the number of levels to be added to the current count \"\"\" new_level = int ( self . level ) + amount if new_level > 275 : raise ValueError ( \"Level should not exceed 275!\" ) else : self . level = new_level","title":"add_level"},{"location":"reference/lazuli/character/#add_luk","text":"def add_luk ( self , amount ) Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool View Source def add_luk ( self , amount ): \"\"\"Add the specified amount to the current existing LUK pool Args: amount: Int, representing the amount of LUK to be added to the current pool \"\"\" new_luk = int ( self . luk ) + amount if new_luk > 32767 : raise ValueError ( \"You should not try to set LUK above 30k!\" ) else : self . luk = new_luk","title":"add_luk"},{"location":"reference/lazuli/character/#add_max_hp","text":"def add_max_hp ( self , amount ) Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool View Source def add_max_hp ( self , amount ): \"\"\"Add the specified amount to the current existing Max HP pool Args: amount: Int, representing the amount of Max HP to be added to the current pool \"\"\" new_hp = int ( self . max_hp ) + amount self . max_hp = new_hp","title":"add_max_hp"},{"location":"reference/lazuli/character/#add_max_mp","text":"def add_max_mp ( self , amount ) Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool View Source def add_max_mp ( self , amount ): \"\"\"Add the specified amount to the current existing Max MP pool Args: amount: Int, representing the amount of max MP to be added to the current pool \"\"\" new_mp = int ( self . max_mp ) + amount self . max_mp = new_mp","title":"add_max_mp"},{"location":"reference/lazuli/character/#add_mesos","text":"def add_mesos ( self , amount ) Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count View Source def add_mesos ( self , amount ): \"\"\"Adds the specified amount to the current meso count Args: amount: Int, representing the amount of mesos to be added to the current count \"\"\" new_amount = int ( self . meso ) + amount if new_amount > 10000000000 : raise ValueError ( \"You should not try to set meso to more than 10b!\" ) else : self . meso = str ( new_amount ) # money is a String ; converting back to String for consistency","title":"add_mesos"},{"location":"reference/lazuli/character/#add_rebirths","text":"def add_rebirths ( self , amount ) View Source def add_rebirths ( self , amount ): # TODO : Add checks new_amount = int ( self . rebirths ) + amount self . rebirths = new_amount","title":"add_rebirths"},{"location":"reference/lazuli/character/#add_str","text":"def add_str ( self , amount ) Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool View Source def add_str ( self , amount ): \"\"\"Add the specified amount to the current existing STR pool Args: amount: Int, representing the amount of STR to be added to the current pool \"\"\" new_str = int ( self . strength ) + amount if new_str > 32767 : raise ValueError ( \"You should not try to set STR above 30k!\" ) else : self . strength = new_str","title":"add_str"},{"location":"reference/lazuli/character/#add_willpower","text":"def add_willpower ( self , amount ) View Source def add_willpower ( self , amount ): # TODO : Add checks new_amount = int ( self . willpower ) + amount self . willpower = new_amount","title":"add_willpower"},{"location":"reference/lazuli/character/#get_char_img","text":"def get_char_img ( self ) Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar View Source def get_char_img ( self ) : \"\"\"Generates character avatar using MapleStory.io API Returns: url: String, a link to the generated avatar \"\"\" equipped_items = [ self . face , self . hair ] equipped_inv = self . inventory . equipped_inv for item in equipped_inv: item_id = equipped_inv [ item ][ \"itemid\" ] equipped_items . append ( item_id ) url = f \"https://maplestory.io/api/GMS/216/Character/200{self.skin}/{str(equipped_items)[1:-1]}/stand1/1\" . replace ( \" \" , \"\" ) return url","title":"get_char_img"},{"location":"reference/lazuli/character/#get_job_name","text":"def get_job_name ( self ) Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID View Source def get_job_name ( self ): \"\"\"Returns the actual name of the job from job id Returns: String, representing the job name corresponding to a job ID \"\"\" return JOBS [ str ( self . job )]","title":"get_job_name"},{"location":"reference/lazuli/character/#get_primary_stats","text":"def get_primary_stats ( self ) Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats View Source def get_primary_stats ( self ): \"\"\"Returns str, int, dex, luk values in a dictionary Returns: dictionary of primary stats \"\"\" primary_stats = { \"str\" : self . strength , \"dex\" : self . dex , \"int\" : self . inte , \"luk\" : self . luk } return primary_stats","title":"get_primary_stats"},{"location":"reference/lazuli/character/#get_stat_by_column","text":"def get_stat_by_column ( self , column ) Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure View Source def get_stat_by_column ( self , column ) : \"\"\"Given a column name, return its value in the database Args: column: string, representing the column in the database from which the value is to be fetched from Returns: string, representing the value in the database associated with the provided column Raises: Generic error on failure \"\"\" try : return self . stats [ column ] except Exception as e : print ( \"[ERROR] Error trying to get stats from given column.\" , e ) return False","title":"get_stat_by_column"},{"location":"reference/lazuli/character/#init_account","text":"def init_account ( self ) Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character:: init (char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method View Source def init_account ( self ): \"\"\"Fetch a dictionary of account attributes from AzureMS's DB and use it to instantiate a new Account object Runs at the end of Character::__init__(char_stats, database_config). Checks the account ID associated with the character instance, and uses the Account class constructor to create a new Account object instance, with the relevant attributes from the database. Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" account_id = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE id = '{self.character_id}'\" ) . get ( \"accountid\" ) # get_db() returns a Dictionary, so get() is used to fetch only the value # The row will always be 0 because there should be no characters with the same character ID (Primary Key) account_info = utils . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE id = '{account_id}'\" ) # The row will always be 0 because there should be no characters with the same account ID (Primary Key) account = Account ( account_info , self . database_config ) return account","title":"init_account"},{"location":"reference/lazuli/character/#init_inventory","text":"def init_inventory ( self ) Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character:: init (char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method View Source def init_inventory ( self ): \"\"\"Fetch a dictionary of user attributes from AzureMS's DB and use it to instantiate a new (custom) Inventory object Runs near the end of Character::__init__(char_stats, database_config). Uses the Character ID associated with the character instance, and the Inventory class constructor to create a new Inventory object instance, with the relevant inventory attributes from the database. Raises: Generic error on failure - handled by the utility.get_db_first_hit() method \"\"\" inventory = Inventory ( self . character_id , self . database_config ) return inventory","title":"init_inventory"},{"location":"reference/lazuli/character/#init_stats","text":"def init_stats ( self ) Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character:: init (char_stats, database_config). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance. View Source def init_stats ( self ) : \"\"\"Given a dictionary of stats from AzureMS's DB we add them to Character object's attributes Runs near the end of Character :: __init__ ( char_stats , database_config ). It assigns the character attributes in char_stats to their respective protected attributes belonging to the Character object instance . \"\"\" self . _character_id = self . _stats [' id '] self . _account_id = self . _stats [' accountid '] self . _name = self . _stats [' name '] self . _level = self . _stats [' level '] self . _exp = self . _stats [' exp '] self . _strength = self . _stats [' str '] self . _dex = self . _stats [' dex '] self . _luk = self . _stats [' luk '] self . _inte = self . _stats [' int '] self . _max_hp = self . _stats [' maxhp '] self . _max_mp = self . _stats [' maxmp '] self . _meso = self . _stats [' meso '] self . _job = self . _stats [' job '] self . _skin = self . _stats [' skincolor '] self . _gender = self . _stats [' gender '] self . _fame = self . _stats [' fame '] self . _hair = self . _stats [ 'ha ir '] self . _face = self . _stats [' face '] self . _ap = self . _stats [' ap '] self . _map = self . _stats [' map '] self . _bl_slots = self . _stats [' buddyCapacity '] self . _rebirths = self . _stats [' reborns '] self . _ambition = self . _stats [' ambition '] self . _insight = self . _stats [' insight '] self . _willpower = self . _stats [' willpower '] self . _diligence = self . _stats [' diligence '] self . _empathy = self . _stats [' empathy '] self . _charm = self . _stats [' charm '] self . _honour = self . _stats [' innerExp '] # Best guess - might be wrong ! self . _mute = self . _stats [' chatban ']","title":"init_stats"},{"location":"reference/lazuli/character/#set_stat_by_column","text":"def set_stat_by_column ( self , column , value ) Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name View Source def set_stat_by_column ( self , column , value ) : \"\"\"Update a character's stats from column name in database Grabs the database attributes provided through the class constructor. Uses these attributes to attempt a database connection. Attempts to update the field represented by the provided column in characterstats, with the provided value. Not recommended to use this alone, as it won't update the character object which this was used from. Args: value: int or string, representing the value to be set in the database column: string, representing the column in the database that is to be updated Returns: A boolean representing whether the operation was successful Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name \"\"\" host = self . _database_config [ \"host\" ] user = self . _database_config [ \"user\" ] password = self . _database_config [ \"password\" ] schema = self . _database_config [ \"schema\" ] port = self . _database_config [ \"port\" ] try : database = con . connect ( host = host , user = user , password = password , database = schema , port = port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE name = '{self.name}'\" ) database . commit () print ( f \"Successfully updated {column} value for character: {self.name}.\" ) self . _stats [ column ] = value # Update the stats in the dictionary database . disconnect () return True except Exception as e : print ( \"[ERROR] Error trying to set stats in database.\" , e ) return False","title":"set_stat_by_column"},{"location":"reference/lazuli/database/","text":"Module lazuli.database Lazuli is designed for use in development of AzureMSv316-based MapleStory private server tools (e.g. Discord bots). Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module contains the main class that users would instantiate: Lazuli. Users can use this class to fetch and manipulate information from the database. Refer to the project wiki on GitHub for more in-depth examples. Typical usage example : lazuli = Lazuli () # Instantiate DB object char = lazuli . get_char_by_name ( \"KOOKIIE\" ) # Instantiate Character object meso = char . money # Use of Character methods to fetch data from DB char . money = 123456789 # Use of Character methods to write data to DB View Source \"\"\"Lazuli is designed for use in development of AzureMSv316-based MapleStory private server tools (e.g. Discord bots). Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module contains the main class that users would instantiate: Lazuli. Users can use this class to fetch and manipulate information from the database. Refer to the project wiki on GitHub for more in-depth examples. Typical usage example: lazuli = Lazuli() # Instantiate DB object char = lazuli.get_char_by_name(\"KOOKIIE\") # Instantiate Character object meso = char.money # Use of Character methods to fetch data from DB char.money = 123456789 # Use of Character methods to write data to DB \"\"\" import mysql.connector as con from lazuli.character import Character from lazuli.account import Account import lazuli.utility as utils class Lazuli : \"\"\"Database object; models the AzureMS DB. Use this class to create instances of AzureMS characters, or inventories, complete with their respective data from the connected AzureMS-based database. Using instance method Lazuli::get_char_by_name(\"name\") will create a Character object (see character.py) instance that has attributes identical to the character with IGN \"name\" in the connected AzureMS-based database. Attributes: host: Optional; IP address of the database. Defaults to \"localhost\" schema: Optional; Name of the schema of the database. Defaults to \"kms_316`\" user: Optional; Username for access to the database. Defaults to \"root\" password: Optional; Password for access to the database. Defaults to \"\" port: Optional; Port with which to access the database. Defaults to 3306 \"\"\" def __init__ ( self , host = \"localhost\" , schema = \"kms_316\" , user = \"root\" , password = \"\" , port = 3306 ): self . _host = host self . _schema = schema self . _user = user self . _password = password self . _port = port self . _database_config = { 'host' : self . host , 'user' : self . user , 'password' : self . password , 'schema' : self . schema , 'port' : self . port } @property def host ( self ): return self . _host @host.setter def host ( self , x ): self . _host = x @property def schema ( self ): return self . _schema @schema.setter def schema ( self , x ): self . _schema = x @property def user ( self ): return self . _user @user.setter def user ( self , x ): self . _user = x @property def password ( self ): return self . _password @password.setter def password ( self , x ): self . _password = x @property def port ( self ): return self . _port @port.setter def port ( self , new_port ): self . _port = new_port def get_char_by_name ( self , char_name ): \"\"\"Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" character_stats = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE `name` = '{char_name}'\" ) # Fetch first result because there should only be one character with that name character = Character ( character_stats , self . _database_config ) return character def get_account_by_username ( self , username ): \"\"\"Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" account_info = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE `name` = '{username}'\" ) # Fetch first result because there should only be one character with that name account = Account ( account_info , self . _database_config ) return account def set_char_stat ( self , name , column , value ): \"\"\"Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name \"\"\" try : database = con . connect ( host = self . host , user = self . user , password = self . password , database = self . schema , port = self . port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE `name` = '{name}'\" ) database . commit () database . disconnect () print ( f \"Successfully set {name}'s stats in database.\" ) return True except Exception as e : print ( \"[ERROR] Error trying to update character stats in Database.\" , e ) return False def get_db_all_hits ( self , query ): \"\"\"Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method \"\"\" data = utils . get_db_all_hits ( self . _database_config , query ) return data def get_online_list ( self ): \"\"\"Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure \"\"\" data = self . get_db_all_hits ( f \"SELECT * FROM accounts WHERE `loggedin` > 0\" ) return data # List of online players def get_online_count ( self ): \"\"\"Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" players = self . get_online_list () return len ( players ) def get_online_players ( self ): \"\"\"Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" player_data = self . get_online_list () return utils . extract_name ( player_data ) def get_level_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `level` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_meso_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `meso` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_fame_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `fame` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_rebirth_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_rebirth_ranking_by_job_id ( self , job_id ): \"\"\"Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( f \"SELECT * FROM `characters` WHERE `job`={job_id} ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) Classes Lazuli class Lazuli ( host = 'localhost' , schema = 'kms_316' , user = 'root' , password = '' , port = 3306 ) Database object; models the AzureMS DB. Use this class to create instances of AzureMS characters, or inventories, complete with their respective data from the connected AzureMS-based database. Using instance method Lazuli::get_char_by_name(\"name\") will create a Character object (see character.py) instance that has attributes identical to the character with IGN \"name\" in the connected AzureMS-based database. Attributes: host: Optional; IP address of the database. Defaults to \"localhost\" schema: Optional; Name of the schema of the database. Defaults to \"kms_316`\" user: Optional; Username for access to the database. Defaults to \"root\" password: Optional; Password for access to the database. Defaults to \"\" port: Optional; Port with which to access the database. Defaults to 3306 View Source class Lazuli : \" \"\" Database object; models the AzureMS DB. Use this class to create instances of AzureMS characters, or inventories, complete with their respective data from the connected AzureMS-based database. Using instance method Lazuli::get_char_by_name(\" name \") will create a Character object (see character.py) instance that has attributes identical to the character with IGN \" name \" in the connected AzureMS-based database. Attributes: host: Optional; IP address of the database. Defaults to \" localhost \" schema: Optional; Name of the schema of the database. Defaults to \" kms_316 `\" user: Optional; Username for access to the database. Defaults to \"root\" password: Optional; Password for access to the database. Defaults to \"\" port: Optional; Port with which to access the database. Defaults to 3306 \"\"\" def __init__(self, host=\"localhost\", schema=\"kms_316\", user=\"root\", password=\"\", port=3306): self._host = host self._schema = schema self._user = user self._password = password self._port = port self._database_config = { 'host': self.host, 'user': self.user, 'password': self.password, 'schema': self.schema, 'port': self.port } @property def host(self): return self._host @host.setter def host(self, x): self._host = x @property def schema(self): return self._schema @schema.setter def schema(self, x): self._schema = x @property def user(self): return self._user @user.setter def user(self, x): self._user = x @property def password(self): return self._password @password.setter def password(self, x): self._password = x @property def port(self): return self._port @port.setter def port(self, new_port): self._port = new_port def get_char_by_name(self, char_name): \"\"\"Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" character_stats = Character.get_db_first_hit( self._database_config, f\"SELECT * FROM characters WHERE ` name ` = '{char_name}'\" ) # Fetch first result because there should only be one character with that name character = Character(character_stats, self._database_config) return character def get_account_by_username(self, username): \"\"\"Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" account_info = Character.get_db_first_hit( self._database_config, f\"SELECT * FROM accounts WHERE ` name ` = '{username}'\" ) # Fetch first result because there should only be one character with that name account = Account(account_info, self._database_config) return account def set_char_stat(self, name, column, value): \"\"\"Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name \"\"\" try: database = con.connect(host=self.host, user=self.user, password=self.password, database=self.schema, port=self.port) cursor = database.cursor(dictionary=True) cursor.execute(f\"UPDATE characters SET {column} = '{value}' WHERE ` name ` = '{name}'\") database.commit() database.disconnect() print(f\"Successfully set {name}'s stats in database.\") return True except Exception as e: print(\"[ERROR] Error trying to update character stats in Database.\", e) return False def get_db_all_hits(self, query): \"\"\"Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method \"\"\" data = utils.get_db_all_hits(self._database_config, query) return data def get_online_list(self): \"\"\"Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure \"\"\" data = self.get_db_all_hits(f\"SELECT * FROM accounts WHERE ` loggedin ` > 0\") return data # List of online players def get_online_count(self): \"\"\"Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" players = self.get_online_list() return len(players) def get_online_players(self): \"\"\"Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" player_data = self.get_online_list() return utils.extract_name(player_data) def get_level_ranking(self): \"\"\"Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` level ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_meso_ranking(self): \"\"\"Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` meso ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_fame_ranking(self): \"\"\"Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` fame ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_rebirth_ranking(self): \"\"\"Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` reborns ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_rebirth_ranking_by_job_id(self, job_id): \"\"\"Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(f\"SELECT * FROM ` characters ` WHERE ` job `={job_id} ORDER BY ` reborns ` DESC LIMIT 5\") return utils.extract_name(player_data) Instance variables host password port schema user Methods get_account_by_username def get_account_by_username ( self , username ) Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method View Source def get_account_by_username ( self , username ) : \" \"\" Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method \"\" \" account_info = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE `name` = '{username}'\" ) # Fetch first result because there should only be one character with that name account = Account ( account_info , self . _database_config ) return account get_char_by_name def get_char_by_name ( self , char_name ) Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method View Source def get_char_by_name ( self , char_name ) : \" \"\" Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method \"\" \" character_stats = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE `name` = '{char_name}'\" ) # Fetch first result because there should only be one character with that name character = Character ( character_stats , self . _database_config ) return character get_db_all_hits def get_db_all_hits ( self , query ) Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method View Source def get_db_all_hits ( self , query ): \"\"\"Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method \"\"\" data = utils . get_db_all_hits ( self . _database_config , query ) return data get_fame_ranking def get_fame_ranking ( self ) Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_fame_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `fame` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) get_level_ranking def get_level_ranking ( self ) Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_level_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `level` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) get_meso_ranking def get_meso_ranking ( self ) Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_meso_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `meso` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) get_online_count def get_online_count ( self ) Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() View Source def get_online_count ( self ): \"\"\"Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" players = self . get_online_list () return len ( players ) get_online_list def get_online_list ( self ) Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure View Source def get_online_list ( self ) : \" \"\" Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure \"\" \" data = self . get_db_all_hits ( f \"SELECT * FROM accounts WHERE `loggedin` > 0\" ) return data # List of online players get_online_players def get_online_players ( self ) Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() View Source def get_online_players ( self ): \"\"\"Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" player_data = self . get_online_list () return utils . extract_name ( player_data ) get_rebirth_ranking def get_rebirth_ranking ( self ) Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_rebirth_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) get_rebirth_ranking_by_job_id def get_rebirth_ranking_by_job_id ( self , job_id ) Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_rebirth_ranking_by_job_id ( self , job_id ) : \" \"\" Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( f \"SELECT * FROM `characters` WHERE `job`={job_id} ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) set_char_stat def set_char_stat ( self , name , column , value ) Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name View Source def set _char_stat ( self , name , column , value ) : \" \"\" Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name \"\" \" try : database = con . connect ( host = self . host , user = self . user , password = self . password , database = self . schema , port = self . port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE `name` = '{name}'\" ) database . commit () database . disconnect () print ( f \"Successfully set {name}'s stats in database.\" ) return True except Exception as e : print ( \"[ERROR] Error trying to update character stats in Database.\" , e ) return False","title":"Database"},{"location":"reference/lazuli/database/#module-lazulidatabase","text":"Lazuli is designed for use in development of AzureMSv316-based MapleStory private server tools (e.g. Discord bots). Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module contains the main class that users would instantiate: Lazuli. Users can use this class to fetch and manipulate information from the database. Refer to the project wiki on GitHub for more in-depth examples. Typical usage example : lazuli = Lazuli () # Instantiate DB object char = lazuli . get_char_by_name ( \"KOOKIIE\" ) # Instantiate Character object meso = char . money # Use of Character methods to fetch data from DB char . money = 123456789 # Use of Character methods to write data to DB View Source \"\"\"Lazuli is designed for use in development of AzureMSv316-based MapleStory private server tools (e.g. Discord bots). Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. This module contains the main class that users would instantiate: Lazuli. Users can use this class to fetch and manipulate information from the database. Refer to the project wiki on GitHub for more in-depth examples. Typical usage example: lazuli = Lazuli() # Instantiate DB object char = lazuli.get_char_by_name(\"KOOKIIE\") # Instantiate Character object meso = char.money # Use of Character methods to fetch data from DB char.money = 123456789 # Use of Character methods to write data to DB \"\"\" import mysql.connector as con from lazuli.character import Character from lazuli.account import Account import lazuli.utility as utils class Lazuli : \"\"\"Database object; models the AzureMS DB. Use this class to create instances of AzureMS characters, or inventories, complete with their respective data from the connected AzureMS-based database. Using instance method Lazuli::get_char_by_name(\"name\") will create a Character object (see character.py) instance that has attributes identical to the character with IGN \"name\" in the connected AzureMS-based database. Attributes: host: Optional; IP address of the database. Defaults to \"localhost\" schema: Optional; Name of the schema of the database. Defaults to \"kms_316`\" user: Optional; Username for access to the database. Defaults to \"root\" password: Optional; Password for access to the database. Defaults to \"\" port: Optional; Port with which to access the database. Defaults to 3306 \"\"\" def __init__ ( self , host = \"localhost\" , schema = \"kms_316\" , user = \"root\" , password = \"\" , port = 3306 ): self . _host = host self . _schema = schema self . _user = user self . _password = password self . _port = port self . _database_config = { 'host' : self . host , 'user' : self . user , 'password' : self . password , 'schema' : self . schema , 'port' : self . port } @property def host ( self ): return self . _host @host.setter def host ( self , x ): self . _host = x @property def schema ( self ): return self . _schema @schema.setter def schema ( self , x ): self . _schema = x @property def user ( self ): return self . _user @user.setter def user ( self , x ): self . _user = x @property def password ( self ): return self . _password @password.setter def password ( self , x ): self . _password = x @property def port ( self ): return self . _port @port.setter def port ( self , new_port ): self . _port = new_port def get_char_by_name ( self , char_name ): \"\"\"Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" character_stats = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE `name` = '{char_name}'\" ) # Fetch first result because there should only be one character with that name character = Character ( character_stats , self . _database_config ) return character def get_account_by_username ( self , username ): \"\"\"Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" account_info = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE `name` = '{username}'\" ) # Fetch first result because there should only be one character with that name account = Account ( account_info , self . _database_config ) return account def set_char_stat ( self , name , column , value ): \"\"\"Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name \"\"\" try : database = con . connect ( host = self . host , user = self . user , password = self . password , database = self . schema , port = self . port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE `name` = '{name}'\" ) database . commit () database . disconnect () print ( f \"Successfully set {name}'s stats in database.\" ) return True except Exception as e : print ( \"[ERROR] Error trying to update character stats in Database.\" , e ) return False def get_db_all_hits ( self , query ): \"\"\"Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method \"\"\" data = utils . get_db_all_hits ( self . _database_config , query ) return data def get_online_list ( self ): \"\"\"Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure \"\"\" data = self . get_db_all_hits ( f \"SELECT * FROM accounts WHERE `loggedin` > 0\" ) return data # List of online players def get_online_count ( self ): \"\"\"Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" players = self . get_online_list () return len ( players ) def get_online_players ( self ): \"\"\"Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" player_data = self . get_online_list () return utils . extract_name ( player_data ) def get_level_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `level` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_meso_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `meso` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_fame_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `fame` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_rebirth_ranking ( self ): \"\"\"Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data ) def get_rebirth_ranking_by_job_id ( self , job_id ): \"\"\"Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self . get_db_all_hits ( f \"SELECT * FROM `characters` WHERE `job`={job_id} ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data )","title":"Module lazuli.database"},{"location":"reference/lazuli/database/#classes","text":"","title":"Classes"},{"location":"reference/lazuli/database/#lazuli","text":"class Lazuli ( host = 'localhost' , schema = 'kms_316' , user = 'root' , password = '' , port = 3306 ) Database object; models the AzureMS DB. Use this class to create instances of AzureMS characters, or inventories, complete with their respective data from the connected AzureMS-based database. Using instance method Lazuli::get_char_by_name(\"name\") will create a Character object (see character.py) instance that has attributes identical to the character with IGN \"name\" in the connected AzureMS-based database. Attributes: host: Optional; IP address of the database. Defaults to \"localhost\" schema: Optional; Name of the schema of the database. Defaults to \"kms_316`\" user: Optional; Username for access to the database. Defaults to \"root\" password: Optional; Password for access to the database. Defaults to \"\" port: Optional; Port with which to access the database. Defaults to 3306 View Source class Lazuli : \" \"\" Database object; models the AzureMS DB. Use this class to create instances of AzureMS characters, or inventories, complete with their respective data from the connected AzureMS-based database. Using instance method Lazuli::get_char_by_name(\" name \") will create a Character object (see character.py) instance that has attributes identical to the character with IGN \" name \" in the connected AzureMS-based database. Attributes: host: Optional; IP address of the database. Defaults to \" localhost \" schema: Optional; Name of the schema of the database. Defaults to \" kms_316 `\" user: Optional; Username for access to the database. Defaults to \"root\" password: Optional; Password for access to the database. Defaults to \"\" port: Optional; Port with which to access the database. Defaults to 3306 \"\"\" def __init__(self, host=\"localhost\", schema=\"kms_316\", user=\"root\", password=\"\", port=3306): self._host = host self._schema = schema self._user = user self._password = password self._port = port self._database_config = { 'host': self.host, 'user': self.user, 'password': self.password, 'schema': self.schema, 'port': self.port } @property def host(self): return self._host @host.setter def host(self, x): self._host = x @property def schema(self): return self._schema @schema.setter def schema(self, x): self._schema = x @property def user(self): return self._user @user.setter def user(self, x): self._user = x @property def password(self): return self._password @password.setter def password(self, x): self._password = x @property def port(self): return self._port @port.setter def port(self, new_port): self._port = new_port def get_char_by_name(self, char_name): \"\"\"Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" character_stats = Character.get_db_first_hit( self._database_config, f\"SELECT * FROM characters WHERE ` name ` = '{char_name}'\" ) # Fetch first result because there should only be one character with that name character = Character(character_stats, self._database_config) return character def get_account_by_username(self, username): \"\"\"Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method \"\"\" account_info = Character.get_db_first_hit( self._database_config, f\"SELECT * FROM accounts WHERE ` name ` = '{username}'\" ) # Fetch first result because there should only be one character with that name account = Account(account_info, self._database_config) return account def set_char_stat(self, name, column, value): \"\"\"Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name \"\"\" try: database = con.connect(host=self.host, user=self.user, password=self.password, database=self.schema, port=self.port) cursor = database.cursor(dictionary=True) cursor.execute(f\"UPDATE characters SET {column} = '{value}' WHERE ` name ` = '{name}'\") database.commit() database.disconnect() print(f\"Successfully set {name}'s stats in database.\") return True except Exception as e: print(\"[ERROR] Error trying to update character stats in Database.\", e) return False def get_db_all_hits(self, query): \"\"\"Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method \"\"\" data = utils.get_db_all_hits(self._database_config, query) return data def get_online_list(self): \"\"\"Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure \"\"\" data = self.get_db_all_hits(f\"SELECT * FROM accounts WHERE ` loggedin ` > 0\") return data # List of online players def get_online_count(self): \"\"\"Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" players = self.get_online_list() return len(players) def get_online_players(self): \"\"\"Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" player_data = self.get_online_list() return utils.extract_name(player_data) def get_level_ranking(self): \"\"\"Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` level ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_meso_ranking(self): \"\"\"Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` meso ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_fame_ranking(self): \"\"\"Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` fame ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_rebirth_ranking(self): \"\"\"Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(\"SELECT * FROM ` characters ` ORDER BY ` reborns ` DESC LIMIT 5\") return utils.extract_name(player_data) def get_rebirth_ranking_by_job_id(self, job_id): \"\"\"Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\"\" player_data = self.get_db_all_hits(f\"SELECT * FROM ` characters ` WHERE ` job `={job_id} ORDER BY ` reborns ` DESC LIMIT 5\") return utils.extract_name(player_data)","title":"Lazuli"},{"location":"reference/lazuli/database/#instance-variables","text":"host password port schema user","title":"Instance variables"},{"location":"reference/lazuli/database/#methods","text":"","title":"Methods"},{"location":"reference/lazuli/database/#get_account_by_username","text":"def get_account_by_username ( self , username ) Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method View Source def get_account_by_username ( self , username ) : \" \"\" Given a username (NOT IGN), create a new account object instance Fetches the user account attributes from the database by querying for username. uses the User class constructor to create a new User object instance, with the said attributes. Useful for getting account information from accounts with no characters. Args: username: String, representing the username used for logging the user into game Returns: Account object with attributes identical to its corresponding entry in the database Raises: Generic error on failure - handled by the Character::get_db() method \"\" \" account_info = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM accounts WHERE `name` = '{username}'\" ) # Fetch first result because there should only be one character with that name account = Account ( account_info , self . _database_config ) return account","title":"get_account_by_username"},{"location":"reference/lazuli/database/#get_char_by_name","text":"def get_char_by_name ( self , char_name ) Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method View Source def get_char_by_name ( self , char_name ) : \" \"\" Create an instance of a Character object from the given character name Uses the class constructor of the Character class to create a new instance, with the corresponding character data and database attributes from the connected database. Args: char_name: string, representing character name (aka IGN) Returns: Character object instantiated with corresponding data from the connected database. Defaults to None if the operation fails. Raises: Generic error on failure - handled by the Character::get_db() method \"\" \" character_stats = Character . get_db_first_hit ( self . _database_config , f \"SELECT * FROM characters WHERE `name` = '{char_name}'\" ) # Fetch first result because there should only be one character with that name character = Character ( character_stats , self . _database_config ) return character","title":"get_char_by_name"},{"location":"reference/lazuli/database/#get_db_all_hits","text":"def get_db_all_hits ( self , query ) Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method View Source def get_db_all_hits ( self , query ): \"\"\"Fetch all matching data from DB using the provided query Wrapper function. Uses the DB config from Lazuli attributes for DB connection. Feeds the config values into utility.get_db_all_hits(). Args: query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: Generic error on failure - handled by the utility.get_db_all_hits() method \"\"\" data = utils . get_db_all_hits ( self . _database_config , query ) return data","title":"get_db_all_hits"},{"location":"reference/lazuli/database/#get_fame_ranking","text":"def get_fame_ranking ( self ) Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_fame_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of fame Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `fame` DESC LIMIT 5\" ) return utils . extract_name ( player_data )","title":"get_fame_ranking"},{"location":"reference/lazuli/database/#get_level_ranking","text":"def get_level_ranking ( self ) Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_level_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of level Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `level` DESC LIMIT 5\" ) return utils . extract_name ( player_data )","title":"get_level_ranking"},{"location":"reference/lazuli/database/#get_meso_ranking","text":"def get_meso_ranking ( self ) Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_meso_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of mesos Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `meso` DESC LIMIT 5\" ) return utils . extract_name ( player_data )","title":"get_meso_ranking"},{"location":"reference/lazuli/database/#get_online_count","text":"def get_online_count ( self ) Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() View Source def get_online_count ( self ): \"\"\"Fetch the number of players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Counts the length of said list, to obtain number of players online. Returns: Int, representing number of players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" players = self . get_online_list () return len ( players )","title":"get_online_count"},{"location":"reference/lazuli/database/#get_online_list","text":"def get_online_list ( self ) Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure View Source def get_online_list ( self ) : \" \"\" Fetch the list of players currently online AzureMS stores login state in the DB, in the 'accounts' table, 'loggedin' column. Lazuli::get_online_list queries for a list of all accounts that are logged in, using the Lazuli::get_db_all_hits method. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure \"\" \" data = self . get_db_all_hits ( f \"SELECT * FROM accounts WHERE `loggedin` > 0\" ) return data # List of online players","title":"get_online_list"},{"location":"reference/lazuli/database/#get_online_players","text":"def get_online_players ( self ) Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() View Source def get_online_players ( self ): \"\"\"Fetch usernames of all players currently online Uses the Lazuli::get_online_list method to fetch the list of all players online. Extract the usernames from the said list. Returns: List, representing all players online. Defaults to False in the event of an error during execution Raises: Generic error on failure, handled by Lazuli::get_online_list() \"\"\" player_data = self . get_online_list () return utils . extract_name ( player_data )","title":"get_online_players"},{"location":"reference/lazuli/database/#get_rebirth_ranking","text":"def get_rebirth_ranking ( self ) Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_rebirth_ranking ( self ) : \" \"\" Fetches the Top 5 players in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( \"SELECT * FROM `characters` ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data )","title":"get_rebirth_ranking"},{"location":"reference/lazuli/database/#get_rebirth_ranking_by_job_id","text":"def get_rebirth_ranking_by_job_id ( self , job_id ) Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names View Source def get_rebirth_ranking_by_job_id ( self , job_id ) : \" \"\" Fetches the Top 5 players of a particular class (specific Job ID), in terms of rebirths Uses Lazuli::get_db_all_hits to query, and utility.extract_name to process the data. Returns: List of Strings, representing player names \"\" \" player_data = self . get_db_all_hits ( f \"SELECT * FROM `characters` WHERE `job`={job_id} ORDER BY `reborns` DESC LIMIT 5\" ) return utils . extract_name ( player_data )","title":"get_rebirth_ranking_by_job_id"},{"location":"reference/lazuli/database/#set_char_stat","text":"def set_char_stat ( self , name , column , value ) Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name View Source def set _char_stat ( self , name , column , value ) : \" \"\" Given a character name and column name, change its value in the database Args: column: string, representing the column in the database name: string, representing the character name in the database value: string/int, representing the value that is to be updated in the corresponding field Returns: boolean, representing whether the operation completed successfully Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column or character name \"\" \" try : database = con . connect ( host = self . host , user = self . user , password = self . password , database = self . schema , port = self . port ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"UPDATE characters SET {column} = '{value}' WHERE `name` = '{name}'\" ) database . commit () database . disconnect () print ( f \"Successfully set {name}'s stats in database.\" ) return True except Exception as e : print ( \"[ERROR] Error trying to update character stats in Database.\" , e ) return False","title":"set_char_stat"},{"location":"reference/lazuli/inventory/","text":"Module lazuli.inventory This module holds the Inventory class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the Inventory class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql.connector as con import lazuli.utility as utils class Inventory : \"\"\"Inventory object; quasi-models AzureMS inventories. The instance method Lazuli::get_char_by_name(name) creates a Character object; as part of lazuli Character object instantiation, an Inventory object instance containing inventory attributes of the character with IGN \"name\" in the connected AzureMS-based database is created. This class contains the appropriate getter methods for said attributes. As a consequence of the inherent complexity of MapleStory's item system, for safety reasons, this module offers NO inventory-write operations (aka setters). Attributes: equip_inv: list of dictionaries, representing in-game items contained by the EQUIP tab consume_inv: list of dictionaries, representing in-game items contained by the USE tab etc_inv: list of dictionaries, representing in-game items contained by the ETC tab install_inv: list of dictionaries, representing in-game items contained by the SETUP tab cash_inv: list of dictionaries, representing in-game items contained by the CASH tab equipped_inv: list of dictionaries, representing in-game items currently equipped by the character \"\"\" def __init__ ( self , character_id , db_config ): \"\"\"Inventory object; quasi-models AzureMS inventories. Modelled after SwordieDB project's Inventory class init method. Due to the inherent complexity of MapleStory's inventory system, this Inventory object will attempt to contain attributes of all 6 of AzureMS's inventory types, using a custom object. Every inventory attribute is a dictionary of dictionaries, the latter of which models the contents of the `inventoryitems` table in a AzureMS-based database. \"\"\" self . _character_id = character_id self . _database_config = db_config self . _equip_inv = self . init_equip_items () self . _use_inv = self . init_use_inv () self . _etc_inv = self . init_etc_inv () self . _cash_inv = self . init_cash_inv () self . _install_inv = self . init_install_inv () self . _equipped_inv = self . init_equipped_inv () @property def database_config ( self ): return self . _database_config @property def character_id ( self ): return self . _character_id @property def equip_inv ( self ): return self . _equip_inv @property def consume_inv ( self ): return self . _use_inv @property def etc_inv ( self ): return self . _etc_inv @property def cash_inv ( self ): return self . _cash_inv @property def install_inv ( self ): return self . _install_inv @property def equipped_inv ( self ): return self . _equipped_inv def load_inv ( self , inv_type ): \"\"\"Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure \"\"\" try : database = con . connect ( host = self . database_config [ 'host' ], user = self . database_config [ 'user' ], password = self . database_config [ 'password' ], database = self . database_config [ 'schema' ], port = self . database_config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"SELECT * FROM inventoryitems WHERE characterid = '{self.character_id}' AND inventorytype = '{inv_type}'\" ) inventory = cursor . fetchall () inv = {} for items in inventory : # More to add if needed. bag_index = items [ \"position\" ] item_id = items [ \"itemid\" ] quantity = items [ \"quantity\" ] is_cash = items [ \"isCash\" ] inventory_type = items [ \"inventorytype\" ] item_stats = { \"itemid\" : item_id , \"quantity\" : quantity , # Never used \"inventorytype\" : inventory_type , \"iscash\" : is_cash # Never used } inv [ bag_index ] = item_stats # Key value, we set as the bag_index aka position of the item in the inventory. return inv except Exception as e : print ( f \"[ERROR] Error trying to load inventory type {inv_type}\" , e ) def init_equip_items ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equip\" )) def init_use_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"use\" )) def init_etc_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"etc'\" )) def init_cash_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"cash\" )) def init_equipped_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equipped\" )) def init_install_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"setup\" )) def has_item_in_equip ( self , item_id ): \"\"\"Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equip_inv , item_id ) def has_item_in_consume ( self , item_id ): \"\"\"Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . consume_inv , item_id ) def has_item_in_etc ( self , item_id ): \"\"\"Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . etc_inv , item_id ) def has_item_in_install ( self , item_id ): \"\"\"Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . install_inv , item_id ) def has_item_in_cash ( self , item_id ): \"\"\"Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . cash_inv , item_id ) def is_equipping ( self , item_id ): \"\"\"Checks whether the EQUIP window (i.e. Hotkey \"E\") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equipped_inv , item_id ) Classes Inventory class Inventory ( character_id , db_config ) Inventory object; quasi-models AzureMS inventories. The instance method Lazuli::get_char_by_name(name) creates a Character object; as part of lazuli Character object instantiation, an Inventory object instance containing inventory attributes of the character with IGN \"name\" in the connected AzureMS-based database is created. This class contains the appropriate getter methods for said attributes. As a consequence of the inherent complexity of MapleStory's item system, for safety reasons, this module offers NO inventory-write operations (aka setters). Attributes: equip_inv: list of dictionaries, representing in-game items contained by the EQUIP tab consume_inv: list of dictionaries, representing in-game items contained by the USE tab etc_inv: list of dictionaries, representing in-game items contained by the ETC tab install_inv: list of dictionaries, representing in-game items contained by the SETUP tab cash_inv: list of dictionaries, representing in-game items contained by the CASH tab equipped_inv: list of dictionaries, representing in-game items currently equipped by the character View Source class Inventory : \"\"\"Inventory object; quasi-models AzureMS inventories. The instance method Lazuli::get_char_by_name(name) creates a Character object; as part of lazuli Character object instantiation, an Inventory object instance containing inventory attributes of the character with IGN \" name \" in the connected AzureMS-based database is created. This class contains the appropriate getter methods for said attributes. As a consequence of the inherent complexity of MapleStory's item system, for safety reasons, this module offers NO inventory-write operations (aka setters). Attributes: equip_inv: list of dictionaries, representing in-game items contained by the EQUIP tab consume_inv: list of dictionaries, representing in-game items contained by the USE tab etc_inv: list of dictionaries, representing in-game items contained by the ETC tab install_inv: list of dictionaries, representing in-game items contained by the SETUP tab cash_inv: list of dictionaries, representing in-game items contained by the CASH tab equipped_inv: list of dictionaries, representing in-game items currently equipped by the character \"\"\" def __init__ ( self , character_id , db_config ) : \"\"\"Inventory object; quasi-models AzureMS inventories. Modelled after SwordieDB project's Inventory class init method. Due to the inherent complexity of MapleStory's inventory system, this Inventory object will attempt to contain attributes of all 6 of AzureMS's inventory types, using a custom object. Every inventory attribute is a dictionary of dictionaries, the latter of which models the contents of the `inventoryitems` table in a AzureMS-based database. \"\"\" self . _character_id = character_id self . _database_config = db_config self . _equip_inv = self . init_equip_items () self . _use_inv = self . init_use_inv () self . _etc_inv = self . init_etc_inv () self . _cash_inv = self . init_cash_inv () self . _install_inv = self . init_install_inv () self . _equipped_inv = self . init_equipped_inv () @property def database_config ( self ) : return self . _database_config @property def character_id ( self ) : return self . _character_id @property def equip_inv ( self ) : return self . _equip_inv @property def consume_inv ( self ) : return self . _use_inv @property def etc_inv ( self ) : return self . _etc_inv @property def cash_inv ( self ) : return self . _cash_inv @property def install_inv ( self ) : return self . _install_inv @property def equipped_inv ( self ) : return self . _equipped_inv def load_inv ( self , inv_type ) : \"\"\"Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure \"\"\" try : database = con . connect ( host = self . database_config [ 'host' ] , user = self . database_config [ 'user' ] , password = self . database_config [ 'password' ] , database = self . database_config [ 'schema' ] , port = self . database_config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"SELECT * FROM inventoryitems WHERE characterid = '{self.character_id}' AND inventorytype = '{inv_type}'\" ) inventory = cursor . fetchall () inv = {} for items in inventory : # More to add if needed . bag_index = items [ \"position\" ] item_id = items [ \"itemid\" ] quantity = items [ \"quantity\" ] is_cash = items [ \"isCash\" ] inventory_type = items [ \"inventorytype\" ] item_stats = { \"itemid\" : item_id , \"quantity\" : quantity , # Never used \"inventorytype\" : inventory_type , \"iscash\" : is_cash # Never used } inv [ bag_index ] = item_stats # Key value , we set as the bag_index aka position of the item in the inventory . return inv except Exception as e : print ( f \"[ERROR] Error trying to load inventory type {inv_type}\" , e ) def init_equip_items ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"equip\" )) def init_use_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"use\" )) def init_etc_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"etc'\" )) def init_cash_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"cash\" )) def init_equipped_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"equipped\" )) def init_install_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"setup\" )) def has_item_in_equip ( self , item_id ) : \"\"\"Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equip_inv , item_id ) def has_item_in_consume ( self , item_id ) : \"\"\"Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . consume_inv , item_id ) def has_item_in_etc ( self , item_id ) : \"\"\"Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . etc_inv , item_id ) def has_item_in_install ( self , item_id ) : \"\"\"Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . install_inv , item_id ) def has_item_in_cash ( self , item_id ) : \"\"\"Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . cash_inv , item_id ) def is_equipping ( self , item_id ) : \"\"\"Checks whether the EQUIP window (i.e. Hotkey \" E \") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equipped_inv , item_id ) Instance variables cash_inv character_id consume_inv database_config equip_inv equipped_inv etc_inv install_inv Methods has_item_in_cash def has_item_in_cash ( self , item_id ) Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_cash ( self , item_id ): \"\"\"Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . cash_inv , item_id ) has_item_in_consume def has_item_in_consume ( self , item_id ) Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_consume ( self , item_id ): \"\"\"Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . consume_inv , item_id ) has_item_in_equip def has_item_in_equip ( self , item_id ) Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_equip ( self , item_id ): \"\"\"Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equip_inv , item_id ) has_item_in_etc def has_item_in_etc ( self , item_id ) Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_etc ( self , item_id ): \"\"\"Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . etc_inv , item_id ) has_item_in_install def has_item_in_install ( self , item_id ) Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_install ( self , item_id ): \"\"\"Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . install_inv , item_id ) init_cash_inv def init_cash_inv ( self ) View Source def init_cash_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"cash\" )) init_equip_items def init_equip_items ( self ) View Source def init_equip_items ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equip\" )) init_equipped_inv def init_equipped_inv ( self ) View Source def init_equipped_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equipped\" )) init_etc_inv def init_etc_inv ( self ) View Source def init_etc_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"etc'\" )) init_install_inv def init_install_inv ( self ) View Source def init_install_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"setup\" )) init_use_inv def init_use_inv ( self ) View Source def init_use_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"use\" )) is_equipping def is_equipping ( self , item_id ) Checks whether the EQUIP window (i.e. Hotkey \"E\") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def is_equipping ( self , item_id ): \"\"\"Checks whether the EQUIP window (i.e. Hotkey \" E \") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equipped_inv , item_id ) load_inv def load_inv ( self , inv_type ) Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure View Source def load_inv ( self , inv_type ) : \"\"\"Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure \"\"\" try : database = con . connect ( host = self . database_config [ 'host' ] , user = self . database_config [ 'user' ] , password = self . database_config [ 'password' ] , database = self . database_config [ 'schema' ] , port = self . database_config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"SELECT * FROM inventoryitems WHERE characterid = '{self.character_id}' AND inventorytype = '{inv_type}'\" ) inventory = cursor . fetchall () inv = {} for items in inventory : # More to add if needed . bag_index = items [ \"position\" ] item_id = items [ \"itemid\" ] quantity = items [ \"quantity\" ] is_cash = items [ \"isCash\" ] inventory_type = items [ \"inventorytype\" ] item_stats = { \"itemid\" : item_id , \"quantity\" : quantity , # Never used \"inventorytype\" : inventory_type , \"iscash\" : is_cash # Never used } inv [ bag_index ] = item_stats # Key value , we set as the bag_index aka position of the item in the inventory . return inv except Exception as e : print ( f \"[ERROR] Error trying to load inventory type {inv_type}\" , e )","title":"Inventory"},{"location":"reference/lazuli/inventory/#module-lazuliinventory","text":"This module holds the Inventory class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the Inventory class for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql.connector as con import lazuli.utility as utils class Inventory : \"\"\"Inventory object; quasi-models AzureMS inventories. The instance method Lazuli::get_char_by_name(name) creates a Character object; as part of lazuli Character object instantiation, an Inventory object instance containing inventory attributes of the character with IGN \"name\" in the connected AzureMS-based database is created. This class contains the appropriate getter methods for said attributes. As a consequence of the inherent complexity of MapleStory's item system, for safety reasons, this module offers NO inventory-write operations (aka setters). Attributes: equip_inv: list of dictionaries, representing in-game items contained by the EQUIP tab consume_inv: list of dictionaries, representing in-game items contained by the USE tab etc_inv: list of dictionaries, representing in-game items contained by the ETC tab install_inv: list of dictionaries, representing in-game items contained by the SETUP tab cash_inv: list of dictionaries, representing in-game items contained by the CASH tab equipped_inv: list of dictionaries, representing in-game items currently equipped by the character \"\"\" def __init__ ( self , character_id , db_config ): \"\"\"Inventory object; quasi-models AzureMS inventories. Modelled after SwordieDB project's Inventory class init method. Due to the inherent complexity of MapleStory's inventory system, this Inventory object will attempt to contain attributes of all 6 of AzureMS's inventory types, using a custom object. Every inventory attribute is a dictionary of dictionaries, the latter of which models the contents of the `inventoryitems` table in a AzureMS-based database. \"\"\" self . _character_id = character_id self . _database_config = db_config self . _equip_inv = self . init_equip_items () self . _use_inv = self . init_use_inv () self . _etc_inv = self . init_etc_inv () self . _cash_inv = self . init_cash_inv () self . _install_inv = self . init_install_inv () self . _equipped_inv = self . init_equipped_inv () @property def database_config ( self ): return self . _database_config @property def character_id ( self ): return self . _character_id @property def equip_inv ( self ): return self . _equip_inv @property def consume_inv ( self ): return self . _use_inv @property def etc_inv ( self ): return self . _etc_inv @property def cash_inv ( self ): return self . _cash_inv @property def install_inv ( self ): return self . _install_inv @property def equipped_inv ( self ): return self . _equipped_inv def load_inv ( self , inv_type ): \"\"\"Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure \"\"\" try : database = con . connect ( host = self . database_config [ 'host' ], user = self . database_config [ 'user' ], password = self . database_config [ 'password' ], database = self . database_config [ 'schema' ], port = self . database_config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"SELECT * FROM inventoryitems WHERE characterid = '{self.character_id}' AND inventorytype = '{inv_type}'\" ) inventory = cursor . fetchall () inv = {} for items in inventory : # More to add if needed. bag_index = items [ \"position\" ] item_id = items [ \"itemid\" ] quantity = items [ \"quantity\" ] is_cash = items [ \"isCash\" ] inventory_type = items [ \"inventorytype\" ] item_stats = { \"itemid\" : item_id , \"quantity\" : quantity , # Never used \"inventorytype\" : inventory_type , \"iscash\" : is_cash # Never used } inv [ bag_index ] = item_stats # Key value, we set as the bag_index aka position of the item in the inventory. return inv except Exception as e : print ( f \"[ERROR] Error trying to load inventory type {inv_type}\" , e ) def init_equip_items ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equip\" )) def init_use_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"use\" )) def init_etc_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"etc'\" )) def init_cash_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"cash\" )) def init_equipped_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equipped\" )) def init_install_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"setup\" )) def has_item_in_equip ( self , item_id ): \"\"\"Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equip_inv , item_id ) def has_item_in_consume ( self , item_id ): \"\"\"Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . consume_inv , item_id ) def has_item_in_etc ( self , item_id ): \"\"\"Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . etc_inv , item_id ) def has_item_in_install ( self , item_id ): \"\"\"Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . install_inv , item_id ) def has_item_in_cash ( self , item_id ): \"\"\"Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . cash_inv , item_id ) def is_equipping ( self , item_id ): \"\"\"Checks whether the EQUIP window (i.e. Hotkey \"E\") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equipped_inv , item_id )","title":"Module lazuli.inventory"},{"location":"reference/lazuli/inventory/#classes","text":"","title":"Classes"},{"location":"reference/lazuli/inventory/#inventory","text":"class Inventory ( character_id , db_config ) Inventory object; quasi-models AzureMS inventories. The instance method Lazuli::get_char_by_name(name) creates a Character object; as part of lazuli Character object instantiation, an Inventory object instance containing inventory attributes of the character with IGN \"name\" in the connected AzureMS-based database is created. This class contains the appropriate getter methods for said attributes. As a consequence of the inherent complexity of MapleStory's item system, for safety reasons, this module offers NO inventory-write operations (aka setters). Attributes: equip_inv: list of dictionaries, representing in-game items contained by the EQUIP tab consume_inv: list of dictionaries, representing in-game items contained by the USE tab etc_inv: list of dictionaries, representing in-game items contained by the ETC tab install_inv: list of dictionaries, representing in-game items contained by the SETUP tab cash_inv: list of dictionaries, representing in-game items contained by the CASH tab equipped_inv: list of dictionaries, representing in-game items currently equipped by the character View Source class Inventory : \"\"\"Inventory object; quasi-models AzureMS inventories. The instance method Lazuli::get_char_by_name(name) creates a Character object; as part of lazuli Character object instantiation, an Inventory object instance containing inventory attributes of the character with IGN \" name \" in the connected AzureMS-based database is created. This class contains the appropriate getter methods for said attributes. As a consequence of the inherent complexity of MapleStory's item system, for safety reasons, this module offers NO inventory-write operations (aka setters). Attributes: equip_inv: list of dictionaries, representing in-game items contained by the EQUIP tab consume_inv: list of dictionaries, representing in-game items contained by the USE tab etc_inv: list of dictionaries, representing in-game items contained by the ETC tab install_inv: list of dictionaries, representing in-game items contained by the SETUP tab cash_inv: list of dictionaries, representing in-game items contained by the CASH tab equipped_inv: list of dictionaries, representing in-game items currently equipped by the character \"\"\" def __init__ ( self , character_id , db_config ) : \"\"\"Inventory object; quasi-models AzureMS inventories. Modelled after SwordieDB project's Inventory class init method. Due to the inherent complexity of MapleStory's inventory system, this Inventory object will attempt to contain attributes of all 6 of AzureMS's inventory types, using a custom object. Every inventory attribute is a dictionary of dictionaries, the latter of which models the contents of the `inventoryitems` table in a AzureMS-based database. \"\"\" self . _character_id = character_id self . _database_config = db_config self . _equip_inv = self . init_equip_items () self . _use_inv = self . init_use_inv () self . _etc_inv = self . init_etc_inv () self . _cash_inv = self . init_cash_inv () self . _install_inv = self . init_install_inv () self . _equipped_inv = self . init_equipped_inv () @property def database_config ( self ) : return self . _database_config @property def character_id ( self ) : return self . _character_id @property def equip_inv ( self ) : return self . _equip_inv @property def consume_inv ( self ) : return self . _use_inv @property def etc_inv ( self ) : return self . _etc_inv @property def cash_inv ( self ) : return self . _cash_inv @property def install_inv ( self ) : return self . _install_inv @property def equipped_inv ( self ) : return self . _equipped_inv def load_inv ( self , inv_type ) : \"\"\"Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure \"\"\" try : database = con . connect ( host = self . database_config [ 'host' ] , user = self . database_config [ 'user' ] , password = self . database_config [ 'password' ] , database = self . database_config [ 'schema' ] , port = self . database_config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"SELECT * FROM inventoryitems WHERE characterid = '{self.character_id}' AND inventorytype = '{inv_type}'\" ) inventory = cursor . fetchall () inv = {} for items in inventory : # More to add if needed . bag_index = items [ \"position\" ] item_id = items [ \"itemid\" ] quantity = items [ \"quantity\" ] is_cash = items [ \"isCash\" ] inventory_type = items [ \"inventorytype\" ] item_stats = { \"itemid\" : item_id , \"quantity\" : quantity , # Never used \"inventorytype\" : inventory_type , \"iscash\" : is_cash # Never used } inv [ bag_index ] = item_stats # Key value , we set as the bag_index aka position of the item in the inventory . return inv except Exception as e : print ( f \"[ERROR] Error trying to load inventory type {inv_type}\" , e ) def init_equip_items ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"equip\" )) def init_use_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"use\" )) def init_etc_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"etc'\" )) def init_cash_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"cash\" )) def init_equipped_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"equipped\" )) def init_install_inv ( self ) : return self . load_inv ( utils . get_inv_type_by_name ( \"setup\" )) def has_item_in_equip ( self , item_id ) : \"\"\"Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equip_inv , item_id ) def has_item_in_consume ( self , item_id ) : \"\"\"Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . consume_inv , item_id ) def has_item_in_etc ( self , item_id ) : \"\"\"Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . etc_inv , item_id ) def has_item_in_install ( self , item_id ) : \"\"\"Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . install_inv , item_id ) def has_item_in_cash ( self , item_id ) : \"\"\"Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . cash_inv , item_id ) def is_equipping ( self , item_id ) : \"\"\"Checks whether the EQUIP window (i.e. Hotkey \" E \") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equipped_inv , item_id )","title":"Inventory"},{"location":"reference/lazuli/inventory/#instance-variables","text":"cash_inv character_id consume_inv database_config equip_inv equipped_inv etc_inv install_inv","title":"Instance variables"},{"location":"reference/lazuli/inventory/#methods","text":"","title":"Methods"},{"location":"reference/lazuli/inventory/#has_item_in_cash","text":"def has_item_in_cash ( self , item_id ) Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_cash ( self , item_id ): \"\"\"Checks whether the CASH tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . cash_inv , item_id )","title":"has_item_in_cash"},{"location":"reference/lazuli/inventory/#has_item_in_consume","text":"def has_item_in_consume ( self , item_id ) Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_consume ( self , item_id ): \"\"\"Checks whether the USE tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . consume_inv , item_id )","title":"has_item_in_consume"},{"location":"reference/lazuli/inventory/#has_item_in_equip","text":"def has_item_in_equip ( self , item_id ) Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_equip ( self , item_id ): \"\"\"Checks whether the EQUIP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equip_inv , item_id )","title":"has_item_in_equip"},{"location":"reference/lazuli/inventory/#has_item_in_etc","text":"def has_item_in_etc ( self , item_id ) Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_etc ( self , item_id ): \"\"\"Checks whether the ETC tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . etc_inv , item_id )","title":"has_item_in_etc"},{"location":"reference/lazuli/inventory/#has_item_in_install","text":"def has_item_in_install ( self , item_id ) Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def has_item_in_install ( self , item_id ): \"\"\"Checks whether the SETUP tab of the inventory has an item Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . install_inv , item_id )","title":"has_item_in_install"},{"location":"reference/lazuli/inventory/#init_cash_inv","text":"def init_cash_inv ( self ) View Source def init_cash_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"cash\" ))","title":"init_cash_inv"},{"location":"reference/lazuli/inventory/#init_equip_items","text":"def init_equip_items ( self ) View Source def init_equip_items ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equip\" ))","title":"init_equip_items"},{"location":"reference/lazuli/inventory/#init_equipped_inv","text":"def init_equipped_inv ( self ) View Source def init_equipped_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"equipped\" ))","title":"init_equipped_inv"},{"location":"reference/lazuli/inventory/#init_etc_inv","text":"def init_etc_inv ( self ) View Source def init_etc_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"etc'\" ))","title":"init_etc_inv"},{"location":"reference/lazuli/inventory/#init_install_inv","text":"def init_install_inv ( self ) View Source def init_install_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"setup\" ))","title":"init_install_inv"},{"location":"reference/lazuli/inventory/#init_use_inv","text":"def init_use_inv ( self ) View Source def init_use_inv ( self ): return self . load_inv ( utils . get_inv_type_by_name ( \"use\" ))","title":"init_use_inv"},{"location":"reference/lazuli/inventory/#is_equipping","text":"def is_equipping ( self , item_id ) Checks whether the EQUIP window (i.e. Hotkey \"E\") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found View Source def is_equipping ( self , item_id ): \"\"\"Checks whether the EQUIP window (i.e. Hotkey \" E \") has an item (i.e. item is equipped) Uses Inventory::has_item_in_inv_type() Returns: Boolean, representing whether the specified item was found \"\"\" return utils . has_item_in_inv_type ( self . equipped_inv , item_id )","title":"is_equipping"},{"location":"reference/lazuli/inventory/#load_inv","text":"def load_inv ( self , inv_type ) Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure View Source def load_inv ( self , inv_type ) : \"\"\"Given an inventory_type, fetch every item associated with it (i.e. -1, 1, 2, 3, 4, 5) Args: inv_type: int Returns: Dictionary of Dictionaries, representing all the in-game items that in the specified inventory type Raises: Generic error on failure \"\"\" try : database = con . connect ( host = self . database_config [ 'host' ] , user = self . database_config [ 'user' ] , password = self . database_config [ 'password' ] , database = self . database_config [ 'schema' ] , port = self . database_config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( f \"SELECT * FROM inventoryitems WHERE characterid = '{self.character_id}' AND inventorytype = '{inv_type}'\" ) inventory = cursor . fetchall () inv = {} for items in inventory : # More to add if needed . bag_index = items [ \"position\" ] item_id = items [ \"itemid\" ] quantity = items [ \"quantity\" ] is_cash = items [ \"isCash\" ] inventory_type = items [ \"inventorytype\" ] item_stats = { \"itemid\" : item_id , \"quantity\" : quantity , # Never used \"inventorytype\" : inventory_type , \"iscash\" : is_cash # Never used } inv [ bag_index ] = item_stats # Key value , we set as the bag_index aka position of the item in the inventory . return inv except Exception as e : print ( f \"[ERROR] Error trying to load inventory type {inv_type}\" , e )","title":"load_inv"},{"location":"reference/lazuli/utility/","text":"Module lazuli.utility This module holds the utility functions and constants for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the utility functions and constants for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql.connector as con # Dictionary that maps inventory tabs' names to their corresponding index in the DB/source map_inv_types = { 'equipped' : - 1 , 'equip' : 1 , 'eqp' : 1 , 'use' : 2 , # Default name for Lazuli purposes 'consume' : 2 , # name in WZ 'etc' : 4 , 'setup' : 3 , # Default name for Lazuli purposes 'install' : 3 , # name in WZ 'cash' : 5 } def get_key ( dictionary , val ): \"\"\"Generic function to return the key for a given value Iterates through the dictionary, comparing values to see if it matches the desired value. If so, return the corresponding key. If no matches are found by the end, return False. This function short-circuits (i.e. returns with the first match found). Note: OrderedDict is no longer necessary for this as of Python 3.6, as order is preserved automagically. Args: dictionary: Dictionary, representing the dictionary to be searched val: Var, representing the desired/target value to search for Returns: Var, representing the corresponding key (if any); defaults to False, if none are found Raises: Generic error for any failures \"\"\" try : for key , value in dictionary . items (): if val == value : return key print ( \"No corresponding key found\" ) return False except Exception as e : print ( f \"Unexpected error encountered whilst attempting to perform dictionary search: {e}\" ) return False def get_inv_type_by_name ( inv_string ): inv_type = map_inv_types . get ( inv_string ) return inv_type def get_inv_name_by_type ( inv_type ): # Never used inv_name = get_key ( map_inv_types , inv_type ) return inv_name def get_db_first_hit ( config , query ): \"\"\"Generic top level function for fetching data (first hit) from DB using the provided DB config and query This method assumes that only one result is found - it always defaults to the first result. An effort has been made to convert this to a decorator so that it may also be applied to Character::set_stat_by_column() & Character::get_user_id(), which ultimately ended in failure. Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: String representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall ()[ 0 ] database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n {e}\" ) def get_db_all_hits ( config , query ): \"\"\"Generic top level function for fetching all matching data from DB using the provided DB config and query Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall () database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n {e}\" ) def has_item_in_inv_type ( inv_type , item_id ): \"\"\"Checks whether the particular tab of the inventory has an item Generic top level function used by Inventory::has_item_in_XXX() methods, and the Inventory::is_equipping() method. Iterates through the dictionary of items associated with the specified tab, and check if the provided item ID can be found as a value. Args: inv_type: inventory object, representing inventory tab to search item_id: int, representing the ID of the item to search for Returns: Boolean, representing whether the specified item was found \"\"\" for bag_index in inv_type : if inv_type [ bag_index ][ 'itemid' ] == item_id : return True return False def extract_name ( player_list ): \"\"\"Extracts a list of players from SQL data, via the name column Args: player_list: List of dicts, representing list of all players Returns: List of Strings, representing player names \"\"\" try : if not player_list [ 0 ][ 'name' ]: # if empty or null; sanity check raise RuntimeError players = [] for player in player_list : players . append ( player [ 'name' ]) return players except Exception as e : print ( f \"ERROR: Error encountered whilst attempting extract list of player names! \\n {e}\" ) Variables map_inv_types Functions extract_name def extract_name ( player_list ) Extracts a list of players from SQL data, via the name column Args: player_list: List of dicts, representing list of all players Returns: List of Strings, representing player names View Source def extract_name ( player_list ): \"\"\"Extracts a list of players from SQL data, via the name column Args: player_list: List of dicts, representing list of all players Returns: List of Strings, representing player names \"\"\" try : if not player_list [ 0 ][ 'name' ]: # if empty or null ; sanity check raise RuntimeError players = [] for player in player_list : players . append ( player [ 'name' ]) return players except Exception as e : print ( f \"ERROR: Error encountered whilst attempting extract list of player names!\\n{e}\" ) get_db_all_hits def get_db_all_hits ( config , query ) Generic top level function for fetching all matching data from DB using the provided DB config and query Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all View Source def get_db_all_hits ( config , query ): \"\"\"Generic top level function for fetching all matching data from DB using the provided DB config and query Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall () database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n{e}\" ) get_db_first_hit def get_db_first_hit ( config , query ) Generic top level function for fetching data (first hit) from DB using the provided DB config and query This method assumes that only one result is found - it always defaults to the first result. An effort has been made to convert this to a decorator so that it may also be applied to Character::set_stat_by_column() & Character::get_user_id(), which ultimately ended in failure. Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: String representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all View Source def get_db_first_hit ( config , query ): \"\"\"Generic top level function for fetching data (first hit) from DB using the provided DB config and query This method assumes that only one result is found - it always defaults to the first result. An effort has been made to convert this to a decorator so that it may also be applied to Character::set_stat_by_column() & Character::get_user_id(), which ultimately ended in failure. Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: String representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall ()[ 0 ] database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n{e}\" ) get_inv_name_by_type def get_inv_name_by_type ( inv_type ) View Source def get_inv_name_by_type ( inv_type ): # Never used inv_name = get_key ( map_inv_types , inv_type ) return inv_name get_inv_type_by_name def get_inv_type_by_name ( inv_string ) View Source def get_inv_type_by_name ( inv_string ): inv_type = map_inv_types . get ( inv_string ) return inv_type get_key def get_key ( dictionary , val ) Generic function to return the key for a given value Iterates through the dictionary, comparing values to see if it matches the desired value. If so, return the corresponding key. If no matches are found by the end, return False. This function short-circuits (i.e. returns with the first match found). Note: OrderedDict is no longer necessary for this as of Python 3.6, as order is preserved automagically. Args: dictionary: Dictionary, representing the dictionary to be searched val: Var, representing the desired/target value to search for Returns: Var, representing the corresponding key (if any); defaults to False, if none are found Raises: Generic error for any failures View Source def get_key ( dictionary , val ): \"\"\"Generic function to return the key for a given value Iterates through the dictionary, comparing values to see if it matches the desired value. If so, return the corresponding key. If no matches are found by the end, return False. This function short-circuits (i.e. returns with the first match found). Note: OrderedDict is no longer necessary for this as of Python 3.6, as order is preserved automagically. Args: dictionary: Dictionary, representing the dictionary to be searched val: Var, representing the desired/target value to search for Returns: Var, representing the corresponding key (if any); defaults to False, if none are found Raises: Generic error for any failures \"\"\" try : for key , value in dictionary . items (): if val == value : return key print ( \"No corresponding key found\" ) return False except Exception as e : print ( f \"Unexpected error encountered whilst attempting to perform dictionary search: {e}\" ) return False has_item_in_inv_type def has_item_in_inv_type ( inv_type , item_id ) Checks whether the particular tab of the inventory has an item Generic top level function used by Inventory::has_item_in_XXX() methods, and the Inventory::is_equipping() method. Iterates through the dictionary of items associated with the specified tab, and check if the provided item ID can be found as a value. Args: inv_type: inventory object, representing inventory tab to search item_id: int, representing the ID of the item to search for Returns: Boolean, representing whether the specified item was found View Source def has_item_in_inv_type ( inv_type , item_id ) : \"\"\"Checks whether the particular tab of the inventory has an item Generic top level function used by Inventory::has_item_in_XXX() methods, and the Inventory::is_equipping() method. Iterates through the dictionary of items associated with the specified tab, and check if the provided item ID can be found as a value. Args: inv_type: inventory object, representing inventory tab to search item_id: int, representing the ID of the item to search for Returns: Boolean, representing whether the specified item was found \"\"\" for bag_index in inv_type : if inv_type [ bag_index ][ 'itemid' ] == item_id : return True return False","title":"Utility"},{"location":"reference/lazuli/utility/#module-lazuliutility","text":"This module holds the utility functions and constants for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. View Source \"\"\"This module holds the utility functions and constants for the lazuli package. Copyright 2020 TEAM SPIRIT. All rights reserved. Use of this source code is governed by a AGPL-style license that can be found in the LICENSE file. Refer to database.py or the project wiki on GitHub for usage examples. \"\"\" import mysql.connector as con # Dictionary that maps inventory tabs' names to their corresponding index in the DB/source map_inv_types = { 'equipped' : - 1 , 'equip' : 1 , 'eqp' : 1 , 'use' : 2 , # Default name for Lazuli purposes 'consume' : 2 , # name in WZ 'etc' : 4 , 'setup' : 3 , # Default name for Lazuli purposes 'install' : 3 , # name in WZ 'cash' : 5 } def get_key ( dictionary , val ): \"\"\"Generic function to return the key for a given value Iterates through the dictionary, comparing values to see if it matches the desired value. If so, return the corresponding key. If no matches are found by the end, return False. This function short-circuits (i.e. returns with the first match found). Note: OrderedDict is no longer necessary for this as of Python 3.6, as order is preserved automagically. Args: dictionary: Dictionary, representing the dictionary to be searched val: Var, representing the desired/target value to search for Returns: Var, representing the corresponding key (if any); defaults to False, if none are found Raises: Generic error for any failures \"\"\" try : for key , value in dictionary . items (): if val == value : return key print ( \"No corresponding key found\" ) return False except Exception as e : print ( f \"Unexpected error encountered whilst attempting to perform dictionary search: {e}\" ) return False def get_inv_type_by_name ( inv_string ): inv_type = map_inv_types . get ( inv_string ) return inv_type def get_inv_name_by_type ( inv_type ): # Never used inv_name = get_key ( map_inv_types , inv_type ) return inv_name def get_db_first_hit ( config , query ): \"\"\"Generic top level function for fetching data (first hit) from DB using the provided DB config and query This method assumes that only one result is found - it always defaults to the first result. An effort has been made to convert this to a decorator so that it may also be applied to Character::set_stat_by_column() & Character::get_user_id(), which ultimately ended in failure. Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: String representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall ()[ 0 ] database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n {e}\" ) def get_db_all_hits ( config , query ): \"\"\"Generic top level function for fetching all matching data from DB using the provided DB config and query Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall () database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n {e}\" ) def has_item_in_inv_type ( inv_type , item_id ): \"\"\"Checks whether the particular tab of the inventory has an item Generic top level function used by Inventory::has_item_in_XXX() methods, and the Inventory::is_equipping() method. Iterates through the dictionary of items associated with the specified tab, and check if the provided item ID can be found as a value. Args: inv_type: inventory object, representing inventory tab to search item_id: int, representing the ID of the item to search for Returns: Boolean, representing whether the specified item was found \"\"\" for bag_index in inv_type : if inv_type [ bag_index ][ 'itemid' ] == item_id : return True return False def extract_name ( player_list ): \"\"\"Extracts a list of players from SQL data, via the name column Args: player_list: List of dicts, representing list of all players Returns: List of Strings, representing player names \"\"\" try : if not player_list [ 0 ][ 'name' ]: # if empty or null; sanity check raise RuntimeError players = [] for player in player_list : players . append ( player [ 'name' ]) return players except Exception as e : print ( f \"ERROR: Error encountered whilst attempting extract list of player names! \\n {e}\" )","title":"Module lazuli.utility"},{"location":"reference/lazuli/utility/#variables","text":"map_inv_types","title":"Variables"},{"location":"reference/lazuli/utility/#functions","text":"","title":"Functions"},{"location":"reference/lazuli/utility/#extract_name","text":"def extract_name ( player_list ) Extracts a list of players from SQL data, via the name column Args: player_list: List of dicts, representing list of all players Returns: List of Strings, representing player names View Source def extract_name ( player_list ): \"\"\"Extracts a list of players from SQL data, via the name column Args: player_list: List of dicts, representing list of all players Returns: List of Strings, representing player names \"\"\" try : if not player_list [ 0 ][ 'name' ]: # if empty or null ; sanity check raise RuntimeError players = [] for player in player_list : players . append ( player [ 'name' ]) return players except Exception as e : print ( f \"ERROR: Error encountered whilst attempting extract list of player names!\\n{e}\" )","title":"extract_name"},{"location":"reference/lazuli/utility/#get_db_all_hits","text":"def get_db_all_hits ( config , query ) Generic top level function for fetching all matching data from DB using the provided DB config and query Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all View Source def get_db_all_hits ( config , query ): \"\"\"Generic top level function for fetching all matching data from DB using the provided DB config and query Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: List of objects, representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall () database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n{e}\" )","title":"get_db_all_hits"},{"location":"reference/lazuli/utility/#get_db_first_hit","text":"def get_db_first_hit ( config , query ) Generic top level function for fetching data (first hit) from DB using the provided DB config and query This method assumes that only one result is found - it always defaults to the first result. An effort has been made to convert this to a decorator so that it may also be applied to Character::set_stat_by_column() & Character::get_user_id(), which ultimately ended in failure. Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: String representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all View Source def get_db_first_hit ( config , query ): \"\"\"Generic top level function for fetching data (first hit) from DB using the provided DB config and query This method assumes that only one result is found - it always defaults to the first result. An effort has been made to convert this to a decorator so that it may also be applied to Character::set_stat_by_column() & Character::get_user_id(), which ultimately ended in failure. Args: config: dictionary, representing database config attributes query: String, representing SQL query Returns: String representing the result of the provided SQL query, using the provided DB connection attributes Raises: SQL Error 2003: Can't cannect to DB WinError 10060: No response from DB List index out of range: Wrong column name Generic error as a final catch-all \"\"\" try : database = con . connect ( host = config [ 'host' ], user = config [ 'user' ], password = config [ 'password' ], database = config [ 'schema' ], port = config [ 'port' ] ) cursor = database . cursor ( dictionary = True ) cursor . execute ( query ) data = cursor . fetchall ()[ 0 ] database . disconnect () return data except Exception as e : print ( f \"CRITICAL: Error encountered whilst attempting to connect to the database! \\n{e}\" )","title":"get_db_first_hit"},{"location":"reference/lazuli/utility/#get_inv_name_by_type","text":"def get_inv_name_by_type ( inv_type ) View Source def get_inv_name_by_type ( inv_type ): # Never used inv_name = get_key ( map_inv_types , inv_type ) return inv_name","title":"get_inv_name_by_type"},{"location":"reference/lazuli/utility/#get_inv_type_by_name","text":"def get_inv_type_by_name ( inv_string ) View Source def get_inv_type_by_name ( inv_string ): inv_type = map_inv_types . get ( inv_string ) return inv_type","title":"get_inv_type_by_name"},{"location":"reference/lazuli/utility/#get_key","text":"def get_key ( dictionary , val ) Generic function to return the key for a given value Iterates through the dictionary, comparing values to see if it matches the desired value. If so, return the corresponding key. If no matches are found by the end, return False. This function short-circuits (i.e. returns with the first match found). Note: OrderedDict is no longer necessary for this as of Python 3.6, as order is preserved automagically. Args: dictionary: Dictionary, representing the dictionary to be searched val: Var, representing the desired/target value to search for Returns: Var, representing the corresponding key (if any); defaults to False, if none are found Raises: Generic error for any failures View Source def get_key ( dictionary , val ): \"\"\"Generic function to return the key for a given value Iterates through the dictionary, comparing values to see if it matches the desired value. If so, return the corresponding key. If no matches are found by the end, return False. This function short-circuits (i.e. returns with the first match found). Note: OrderedDict is no longer necessary for this as of Python 3.6, as order is preserved automagically. Args: dictionary: Dictionary, representing the dictionary to be searched val: Var, representing the desired/target value to search for Returns: Var, representing the corresponding key (if any); defaults to False, if none are found Raises: Generic error for any failures \"\"\" try : for key , value in dictionary . items (): if val == value : return key print ( \"No corresponding key found\" ) return False except Exception as e : print ( f \"Unexpected error encountered whilst attempting to perform dictionary search: {e}\" ) return False","title":"get_key"},{"location":"reference/lazuli/utility/#has_item_in_inv_type","text":"def has_item_in_inv_type ( inv_type , item_id ) Checks whether the particular tab of the inventory has an item Generic top level function used by Inventory::has_item_in_XXX() methods, and the Inventory::is_equipping() method. Iterates through the dictionary of items associated with the specified tab, and check if the provided item ID can be found as a value. Args: inv_type: inventory object, representing inventory tab to search item_id: int, representing the ID of the item to search for Returns: Boolean, representing whether the specified item was found View Source def has_item_in_inv_type ( inv_type , item_id ) : \"\"\"Checks whether the particular tab of the inventory has an item Generic top level function used by Inventory::has_item_in_XXX() methods, and the Inventory::is_equipping() method. Iterates through the dictionary of items associated with the specified tab, and check if the provided item ID can be found as a value. Args: inv_type: inventory object, representing inventory tab to search item_id: int, representing the ID of the item to search for Returns: Boolean, representing whether the specified item was found \"\"\" for bag_index in inv_type : if inv_type [ bag_index ][ 'itemid' ] == item_id : return True return False","title":"has_item_in_inv_type"}]}